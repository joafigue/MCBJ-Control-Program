#+OPTIONS: ':nil *:t -:t ::t <:t H:5 \n:nil ^:t arch:headline author:t c:nil
#+OPTIONS: creator:nil d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t
#+OPTIONS: num:t p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t timestamp:t
#+OPTIONS: title:t toc:t todo:nil |:t
#+TITLE: Measure_samples
#+DATE: <2016-08-10 Wed>
#+AUTHOR:
#+EMAIL: joaquin@joaquin_laptop
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 24.5.1 (Org mode 8.3.4)


* Introduction
This file is a try to document and enhance the program in python to measure the samples through the mechanism of of break-junction in gold samples for the study of molecular properties.
The reason for this is that the current program, while functional is underdocumented and the full how-to is preserved through *oral tradition* which is regrettable for an investigation lab, and since the author of this document has a bit of experience in software development and documentation, this file was born.

** Break Junction
The experiment is to measure the break junction


**  Actuators and measuremnts
The program uses 2 different mechanical actuators to perform the measurements, and there are 2 different kind of samples to be measured. Finally the measurement is performed by analyzing the conductance of the sample.

*** Mechanical actuators
Since the experiment is based on a single gold "nano-wire"  which is broken through mechanical means, there is need for mechanical acutators to beak the "wire" to measure the conductance change.

**** Faulhaber Motor
The Faulhaber motor is used to perform relatively large movements on the sample and is used to break the sample initially

**** Piezo actuator
Once the junction is broken, the motor is turned off and the piezo-device is used, since it provides a simple controllable way to perform even samller movements on the piece for the study

*** Samples types
Even though the experiment is always performed over gold "wires", there are 2 distinct clasification of the samples.
# So far it seems (to me) that regardless of the type of measurement the mechanism is the same
**** Clean gold
Since the gold is the sustrate, is measured to ensure that is clean and there are no impurities prior to a real measurement

**** Gold + Molecule
The focus of the experiment is to measure the transport (conductance) properties of a given molecule, thus once a gold sustrate has been measured and confirmed to be usable, a molecule solution is placed on the sustrate with the expectation that a molecule gets inserted in the gap between the gold terminals.

*** ADWin mesurement
The measurement of the conductance is performed using the ADWin board which has an interface and binding to python. The documentation for the ADWin measurement instrument can be found on the [[http://www.adwin.de/us/download/linux.html][Download page]]

Since the objective is to measure the transport properties, the most important parameters to measure are the conductance and the separation between the gold contacts (break junction)

* Program Description
As it was already stated the measurement is splitted in 2 steps, the motor initialization and the piezo measurement, however a full program cannot be limited to these 2 steps, as there are additional requirements uch as a user interface for the program. Thus the program is organized as:
- Main loop :: As in many programs the main loop is the one that orchestrates the execution of the program. For details see [[Main Loop]]
- UI Interface :: Considering the requiremens for different configurations for the measurement such as the voltage applied to the juncture, there is a requierement for a reasonable to use UI, and this UI should allow the user to run a measurement. For details see [[User Interface]]
- motor break :: Using the motor actuator, a break juncture is created and then the displacement is set so that a movement generated with the piezo-electric actuator the juncture can be easily reconstructed. For details see [[Motor break junction]]
- Measurement with the piezo :: With the sample in the optimal setting for the piezo is the measured by modifying the voltage applied to the piezo-electric device which in turn creates a displacement of the sample recreating the juncture an allowing for easily repetable measurements through the dynamic range of the piezo-electric device. For details see [[Measurement with Piezo]]

Obviously there is a series of additional modules which provide the interface to the different actuators, and additional helpeer functions to improve the presentation of the results, all of which will be presented in turn.

** DONE Main Loop
   :PROPERTIES:
   :tangle:   main.py
   :comments: link
   :END:
#+BEGIN_SRC python :exports none
  #################################################################
  ## @file    Main.py
  #  @author  Joaquin Figueroa
  #  @brief   Main file for measuring break-junction experiments
  #
  #  @details This is the main file for the program used to
  #           measure samples using the break-junction technique.
  #           This program provides a GUI to control the execution
  #           based on providing the tools to configure a run.
  #           The program automates the whole procedure by:
  #           1- Automating the creation of the break junction
  #           using the motor
  #           2- Automating the measurement process using a piezo
  #           actuator.
  #################################################################
#+END_SRC
As with many considerable programs this one stars importing the necesary files. In this case, all the modules imported for the main file come from the modules created for the program.
#+BEGIN_SRC python
  import sys
  from modules.ui_config import *
  from modules.motor_break import *
  from modules.piezo_measure import *
#+END_SRC 

The main loop is indeed a loop. It is intended to work in the following way.
- First the UI is presented to the user, so the user can modify the configuration of the experiment. As a result from the UI execution there are 3 possible outcomes:
  1. Exit the program
     #+BEGIN_SRC python
       ############################################################
       ## @fn    : main_exit
       #  @brief : Terminates program execution
       ############################################################
       def main_exit(config) :
           print("Program Finished successfully")
           sys.exit()
     #+END_SRC
  2. Excecute only the junction creation. This is to prepare a clean sample, since there is no benefit to measure using the piezo a clean sample
     #+BEGIN_SRC python
       ############################################################
       ## @fn      : main_motor_break
       #  @details : Commands the motor to break the gold channel
       #             creating a break-junction and then joins it
       #             again leaving it ready for measurement
       ############################################################
       def main_motor_break(config):
           motor_break_juncture()
     #+END_SRC
  3. Execute a full measurement, creating the juncture and then measure the molecule
     #+BEGIN_SRC python
       ############################################################
       ## @fn      : main_measure
       #  @details : Measures the transport properties of the
       #             sample by creating the break-junction with the
       #             motor, and using the piezo to measure
       ############################################################
       def main_measure(config):
           motor_break_juncture()
           measure_sample()
     #+END_SRC

The outcome picked by the user must be translated into a command in the program, this is performed in a similar way as a switch-case, but in python is implemented as a dictionary test, which may seem odd for someone not used to the technique. For reference please see [[http://www.pydanny.com/why-doesnt-python-have-switch-case.html][switch-case in python.]]
#+BEGIN_SRC python
  ############################################################
  ## @fn      : execute_ui_cmd
  #  @details : Analyzed the command chosen by the user and
  #             executes it. Options are:
  #             1- End program
  #             2- only perform break-junction
  #             3- perform full measurement of the sample
  ############################################################
  def execute_ui_cmd(ui_cmd,config) :
      switch = {
          UI_CMD.EXIT    : main_exit,
          UI_CMD.M_BREAK : main_motor_break,
          UI_CMD.MEASURE : main_measure,
      }
      cmd = switch.get(ui_cmd, sys.exit)
      cmd(config)
#+END_SRC

Finally the main loop is executed indefinitely until the user terminates the program

#+BEGIN_SRC python
  ############################################################
  ## @details : Main loop. Executes UI Cmd until the user end
  ##            the program
  ############################################################
  def main():
      while True :
          ui_config = ui_get_gui_config()
          ui_cmd    = ui_config.cmd
          config    = ui_config.config
          config._b_params.print_all()
          execute_ui_cmd(ui_cmd,config)

  if __name__ == "__main__":
      main()
#+END_SRC

** TODO User Interface
   :PROPERTIES:
   :noweb:    tangle
   :comments: link
   :END:
The user interface has 2 requirements.
1. It should allow the user to run the experiment
2. It should allow the user to tweak with the configuration for the experiment

Now there is an additional requirement for the UI, which is the interface by itself, thus the UI module can be thought as the result of 2 pieces.
- Program Interface :: The UI - program interface is how the UI interacts with the rest of the program. See [[UI - Program Interface]]
- GUI :: The graphical User interface is how the program interacts with the user. See [[UI - GUI]]

*** TODO UI - Program Interface
   :PROPERTIES:
   :tangle:   modules/ui_config.py
   :END:
# As with any module there is a section for the imports and the file headers, but these are unninteresting for any reader, thus they are put in comments and not exported to a PDF/HTML result
#+BEGIN_SRC python :exports none
  #################################################################
  ## @file    ui_config.py
  #  @author  Joaquin Figueroa
  #  @date    Fri Aug 12 2016
  #  @brief   Provides the definitions and parameters for the UI
  #
  #  @details This file provides a all the necessary helper
  #           functions to interface the different parameters
  #           with the program.
  #################################################################
  from PyQt4 import QtGui
  from PyQt4 import QtCore
  from modules.ui_gui import run_gui
  import sys
  <<ui-basic-params-defaults>>
  <<ui-advanced-params-defaults>>
  <<ui-presentation-params-defaults>>
#+END_SRC

Therefore the output of the UI execution is a class of 2 values with one value being the command to be executed, and the other the configuration for the measurements, which has a default initialization, but also provides functions to replace the original values with new ones
 #+BEGIN_SRC python
   ############################################################
   ## @class   UI_CONFIG
   #  @details This class has the return type of the UI class
   #           The return type has:
   #           1- Command to be executed (exit, measure)
   #           2- Configuration for the measurements
   ############################################################
   class UI_CONFIG:
       def __init__(self):
           self.cmd    = UI_CMD.EXIT
           self.config = UI_CONFIG_PARAMS()

       ############################################################
       ## @brief   Updates the ui_cmd with a new one
       ############################################################
       def update_cmd(self, new_cmd):
           self.cmd = new_cmd

       ############################################################
       ## @brief   Updates the config with a new one
       ############################################################
       def update_config(self, new_config):
           self.config = new_config
 #+END_SRC
 
**** DONE UI command
  Now the command to be executed has only a few possible values, which are used to, as previously explained, to terminate the program, or execute one of the routines.
  #+BEGIN_SRC python
    ############################################################
    ## @class  CMD
    #  @brief  UI calss to encode the possible commands for the
    #         program
    ############################################################
    class UI_CMD:
        EXIT    = 0
        M_BREAK = 1
        MEASURE = 2
  #+END_SRC 

**** TODO UI Configuration Parameters
The UI configuration is a list of variables which are used through the measurements for configuring the experiments or for controlling the presentation of the results, for simplicity the variables are classified in groups
- Basic parameters :: These are the parameters that control the run and define it see [[UI - Basic parameters ]]
- Advanced parameters :: There are more advanced parameters that influence the run, but have minor impact (usually) when compared with the other parameters, and the user is rarely ever expected to modify them. See [[UI - Advanced parameters]]
- Presentation parameters :: The results of the experiment is processed in graph; some of the parameters for the graph can be tweaked to improve the readability of them. See [[UI - Presentation]]

#+BEGIN_SRC python
  ############################################################
  ## @class   UI_CONFIG
  #  @details This class stores all configuration values to be
  #           used for the measurements.
  ############################################################
  class UI_CONFIG_PARAMS:
      def __init__(self):
          self._b_params = basic_params()
          self._a_params = adv_params()
          self._p_params = presentation()

      <<ui-config-bp-interface>>
      <<ui-config-ap-interface>>
      <<ui-config-pp-interface>>
#+END_SRC


Finally the interface with the rest of the program is defined through a single method

#+BEGIN_SRC python
  def ui_get_gui_config():
      retval = run_gui()
      return retval
#+END_SRC

Before describing each parameter group, is clear that most parameters are numerical, therefore it makes sense to define a class which encapsulates the common functionality for the numerical parameters. This class is defined in [[Numerical Parameters definition]]

***** DONE Numerical Parameters definition
As previously stated most parameters are numerical, so a parent class is created to provide a common interface for them all and to ensure that all numerical parameters behave consistently.
The numerical parameters are defined in [[src-config-num-param-class]], which provides the interfaces that define the numerical parameters
- Initialization function :: The function defined in line [[(src-np-init)]], provide the initialization code for a generic numerical parameter, which is defined by the following parameters:
  - Default Value :: Is the value that the parameter takes by default, such as the voltage for the juncture.
  - Minimum value :: The minimum value acceptable for the parameter. With the maximum value defines the range of admissible values
  - Maximum value :: The maximum value acceptable for the parameter. With the minimum value defines the range of admissible values
  - Name :: The name defines a name for the parameter, which is useful to print information about it. 
- Reset function :: Defined in line  [[(src-np-reset)]], provides a mechanism to restore the parameter value to its default.
- Validation function ::  Defined in line [[(src-np-validation)]] returns a boolean determining if the new value is within the range of accepted values
- Update function :: Defined in line  [[(src-np-update)]] updates the juncture voltage to a new value defined by the user, only if the value is within the accepted range, but if not it leaves the value unchanged
- Print function ::  Defined in line  [[(src-np-print)]] provides an utility to print the current value to the terminal. Useful during testing and for sending messages


#+CAPTION: Numerical parameters class definition
#+NAME: src-config-num-param-class
#+BEGIN_SRC python  -n -r
  #############################################################
  ## @class   Numerical Parameter
  #  @brief   All functionality related to the numerical
  #           parameters
  #
  #  @details This class defines the basic behavior common to
  #           all numerical parameters, including common
  #           interfaces and values.
  #############################################################
  class numerical_parameter(object):
      #############################################################
      ## @brief   Initilaization code
      #############################################################
      def __init__(self,name,dflt_val,min_val,max_val):#(ref:src-np-init)
          self._dflt = dflt_val
          self._min = min_val
          self._max = max_val
          self.name = name
          self.reset()
      #############################################################
      ## @brief   restores the default value of the parameter
      #############################################################
      def reset(self): #(ref:src-np-reset)
          self.value = self._dflt
      #############################################################
      ## @brief   Determines if a new value is in the permited
      #           range
      #############################################################
      def validate(self, val):#(ref:src-np-validation)
          return (self._min <= val) & (val <= self._max)
      #############################################################
      ## @brief   Updates the stored value only if the new
      #           value is within range
      #############################################################
      def update(self,new_val):#(ref:src-np-update)
          if self.validate(new_val):
              self.value = new_val
      #############################################################
      ## @brief   Prints the parameter name and its value
      #############################################################
      def print_param(self):#(ref:src-np-print)
          print("%s = %f" % (self.name, self.value))
#+END_SRC

There is also a requirement to treat some numerical parameters as integers, therefore a specialization of the numerical parameters is shown in  [[src-config-int-param-class]], where some modifications and overloading are executed to provide with the desired properties.
- Values must be integers :: This class must have all its values as integers, thus the default values and other parameters are cast as integers.
- Validation Function :: Defined in line [[(src-ip-validation)]], this function also confirms that the parameter is an integer
- Print as integer :: The printing function defined in line  [[(src-ip-print)]], changes the format to ensure that the parameter is displayed as an integer and not as a float. This is a minor change, but desirable for consistency.

#+CAPTION: Integer parameters class definition
#+NAME: src-config-int-param-class
#+BEGIN_SRC python  -n -r
  #############################################################
  ## @class   Integer Parameter
  #  @brief   All functionality related to the numerical
  #           parameters that are to be treated as int
  #############################################################
  class integer_parameter(numerical_parameter):
      #############################################################
      ## @brief   Initilaization code
      #############################################################
      def __init__(self,name,dflt_val,min_val,max_val):
          _dflt = int(dflt_val)
          _min = int(min_val)
          _max = int(max_val)
          super(integer_parameter,self).__init__(name,_dflt,_min,_max)
      #############################################################
      ## @brief   Determines if a new int value is in the permited
      #           range, and integer
      #############################################################
      def validate(self, val): # (ref:src-ip-validation)
          is_valid = super(integer_parameter,self).validate(val)
          return  float(val).is_integer() & is_valid
      #############################################################
      ## @brief   Prints the parameter name and its value
      #############################################################
      def print_param(self): # (ref:src-ip-print)
          print("%s = %d" % (self.name, self.value))
#+END_SRC


****** Numerical Parameter Test                                    :noexport:
 Test the functionality of a generic numerical parameter. Just excecuted by using =C-c C-c=. Should all be true
 #+BEGIN_SRC python :tangle no
   import modules.ui_config as c
   tp = c.numerical_parameter("Test", 7.8, 0.5,50)
   t1 = tp.value == 7.8
   t2 = tp.validate(-1.1) == False
   tp.update(0.12)
   t3 = tp.value == 7.8
   tp.update(9)
   t4 = tp.value == 9
   t5 = tp.validate(88) == False
   tp.update(55)
   t6 = tp.value == 9
   tp.update(0.7)
   t7 = tp.value == 0.7
   tp.reset()
   t8 = tp.value == 7.8
   t9 = tp.name == "Test"
   return [t1,t2,t3,t4,t5,t6,t7,t8,t9]
 #+END_SRC

 #+RESULTS:
 | True | True | True | True | True | True | True | True | True |


***** TODO UI - Basic parameters
The basic parameters used to configure the measurement are parameters that are the most likely to be modified by the used, and whose side effects are better understood. These parameters usually deal with the speed and number of data points. 
In a more traditional object oriented paradigm, each parameter is controlled by its own class, which defines their default values, range, validation functions and how each parameter is updated.

The basic parameters are:
- Juncture Voltage :: This represents the voltage applied to the junture. See [[Juncture Voltage]]
- Piezo Speed Breaking :: This parameters defines the voltage rate which is applied to the piezoelectric, which has a direct impact on the juncture. See [[Piezo Speed Breaking]]
- Number of traces :: Traces are each process of opening and closing the juncture using the piezoelectric device. Each trace is a full cycle, and the number of traces represent the number of measurements to be taken. See [[Number of traces]]
- Data directory :: The results of the experiment are stored in a specific directory. See [[Data directory]]


#+BEGIN_SRC python
  class basic_params:
        def __init__(self):
              self.juncture = juncture_voltage()
              self.piezo_speed = piezo_speed()
              self.traces = traces()
              self.data_dir = data_dir()
        def restore_defaults(self):
              self.juncture.reset()
              self.piezo_speed.reset()
              self.traces.reset()
              self.data_dir.reset()
        def print_all(self):
              print("--- Basic Parameters ---")
              self.juncture.print_param()
              self.piezo_speed.print_param()
              self.traces.print_param()
              print("Directory = %s" % self.data_dir.path)
#+END_SRC

****** DONE Juncture Voltage
The juncture voltage defined in [[src-config-juncture-voltage-class]], as previously stated, is the parameter that controls the voltage applied to the juncture during the analysis. The juncture voltage class is just a specialization of the Numerical parameter class described in [[Numerical Parameters definition]]

#+CAPTION: Juncture voltage class definition
#+name: src-config-juncture-voltage-class
#+BEGIN_SRC python  -n -r
  #############################################################
  ## @class   juncture_voltage
  #  @brief   All functionality related to the juncture voltage
  #
  #  @details This class defines the behavior of the jucture
  #           voltage. Provides the default values and range
  #           plus the corresponding interface.
  #############################################################
  class juncture_voltage(numerical_parameter):
      #############################################################
      ## @brief   Initilaization code
      #############################################################
      def __init__(self):
          _dflt = 0.1 # (ref:src-jv-dflt)
          _min = 0.0  #(ref:src-jv-min)
          _max = 0.3  #(ref:src-jv-max)
          _name = "Juncture Voltage"
          super(juncture_voltage, self).__init__(_name,_dflt, _min, _max)
#+END_SRC

******* voltage test                                               :noexport:
Test functionality. Just excecuted by using =C-c C-c=. Should all be true
#+BEGIN_SRC python :tangle no
  import modules.ui_config as c
  jv = c.juncture_voltage()
  t1 = jv.value == 0.1
  t2 = jv.validate(1.1) == False
  jv.update(2)
  t3 = jv.value == 0.1
  jv.update(0.2)
  t4 = jv.value == 0.2
  t5 = jv.validate(-1.1) == False
  jv.update(5)
  t6 = jv.value == 0.2
  jv.update(0.22)
  t7 = jv.value == 0.22
  jv.reset()
  t8 = jv.value == 0.1
  t9 = jv.name == "Juncture Voltage"
  return [t1,t2,t3,t4,t5,t6,t7,t8,t9]
#+END_SRC

 #+RESULTS:
 | True | True | True | True | True | True | True | True | True |

****** DONE Piezo Speed Breaking
The piezo speed breaking defined in [[src-config-piezo-speed-class]] is the parameter that controls the speed at which each measurement cycle is executed, defined in \([V/s]\). The Piezo speed class is just a specialization of the Numerical parameter class described in [[Numerical Parameters definition]], with the additional fixed speed value.

#+CAPTION: Piezo speed breaking class definition
#+name: src-config-piezo-speed-class
#+BEGIN_SRC python -n -r
  #############################################################
  ## @class   piezo_speed
  #  @brief   All functionality related to the
  #           piezo_speed_breaking
  #
  #  @details This class defines the behavior of the piezo
  #           speed voltage relations which is defined in [V/s]
  #           Provides the default values and range plus the
  #           corresponding interfaces.
  #############################################################
  class piezo_speed(numerical_parameter):
      #############################################################
      ## @brief   Initilaization code
      #############################################################
      def __init__(self):
          _dflt = 300.0 #(ref:src-ps-dflt)
          _min = 30.0   #(ref:src-ps-min)
          _max = 300.0  #(ref:src-ps-max)
          _name = "Piezo Speed"
          super(piezo_speed, self).__init__(_name,_dflt, _min, _max)
          self.fixed_speed = _dflt
#+END_SRC
******* Piezo speed test                                           :noexport:
Test functionality. Just executed by using =C-c C-c=. Should all be true
#+BEGIN_SRC python :tangle no
  import modules.ui_config as c
  ps = c.piezo_speed()
  t1 = (ps.value == 300.0) & (ps.fixed_speed == 300.0)
  t2 = ps.validate(331.1) == False
  ps.update(334.2)
  t3 = (ps.value == 300.0) & (ps.fixed_speed == 300.0)
  ps.update(45.2)
  t4 = (ps.value == 45.2) & (ps.fixed_speed == 300.0)
  t5 = ps.validate(2.1) == False
  ps.update(700)
  t6 = (ps.value == 45.2) & (ps.fixed_speed == 300.0)
  ps.update(90)
  t7 = (ps.value == 90) & (ps.fixed_speed == 300.0)
  ps.reset()
  t8 = (ps.value == 300) & (ps.fixed_speed == 300.0)
  ps.update(-90)
  t9 = (ps.value == 300) & (ps.fixed_speed == 300.0)
  return [t1,t2,t3,t4,t5,t6,t7,t8,t9]
#+END_SRC

#+RESULTS:
| True | True | True | True | True | True | True | True | True |

****** DONE Number of traces
The number of traces defined in [[src-config-traces-class]] is the parameter that controls the number of measurement cycles excecuted using the piezoelectric actuator, where a trace is a full cycle going from closed to open and back. The traces class is a simple specialization of the Integer parameter class described in [[Numerical Parameters definition]] ([[src-config-int-param-class]]).

#+CAPTION: Number of traces class definition
#+NAME: src-config-traces-class
#+BEGIN_SRC python -n -r
  #############################################################
  ## @class   traces
  #  @brief   All functionality related to the number of traces
  #
  #  @details This class defines the parameter that controls
  #           the number of traces (runs) performed using the
  #           piezo. Each trace correspond to a full cycle
  #           from closed juncture to open and back.
  #############################################################
  class traces(integer_parameter):
        #############################################################
        ## @brief   Initilaization code
        #############################################################
        def __init__(self):
            _dflt = int(5000)  #(ref:src-tr-dflt)
            _min = int(1)      #(ref:src-tr-min)
            _max = int(20000)  #(ref:src-tr-max)
            _name = "Number of Traces"
            super(traces, self).__init__(_name,_dflt, _min, _max)
#+END_SRC
******* number traces test                                         :noexport:
#+BEGIN_SRC python :tangle no
  import modules.ui_config as c
  tr = c.traces()
  t1 = tr.value == 5000
  t2 = tr.validate(40000) == False
  tr.update(5.2)
  t3 = tr.value == 5000
  tr.update(200)
  t4 = tr.value == 200
  t5 = tr.validate(-100) == False
  tr.update(120000)
  t6 = tr.value == 200
  tr.update(8000)
  t7 = tr.value == 8000
  tr.reset()
  t8 = tr.value == 5000
  return [t1,t2,t3,t4,t5,t6,t7,t8]
#+END_SRC

#+RESULTS:
| True | True | True | True | True | True | True | True |

****** TODO Data directory
#+BEGIN_SRC python -n -r
  #############################################################
  ## @class   traces
  #  @brief   All functionality related to the data directory
  #
  #  @details This class defines the parameter that controls
  #           where the results will be stored. PENDING- TODO
  #############################################################
  class data_dir:
      _dflt = "./" #(ref:src-dd-dflt)
      _subdir_fmt= "data"
      #############################################################
      ## @brief   Initilaization code
      #############################################################
      def __init__(self):
          self.reset()
      ##############################################################
      ## @brief   restores the default value of the number of traces
      ##############################################################
      def reset(self): #(ref:src-dd-reset)
          self.path = self._dflt
      ## @brief   there is no need to validate?
      def validate(self, aux_val):#(ref:src-dd-validation)
          return True
      #############################################################
      ## @brief   Updates the piezo speed only if the new
      #           value is within range. Ensures it's an int
      #############################################################
      def update(self,new_path):#(ref:src-dd-update)
          if self.validate(new_path):
              self.path = new_path
#+END_SRC


#+NAME: ui-config-bp-interface
#+BEGIN_SRC python

#+END_SRC

***** TODO UI - Advanced parameters
#+BEGIN_SRC python
  class adv_params:
        def __init__(self):
              self.asdf = 1
#+END_SRC

#+NAME: ui-config-ap-interface
#+BEGIN_SRC python

#+END_SRC

#+name: ui-advanced-params-defaults
#+BEGIN_SRC python :exports none
piezo_start_V = 0.0         # V
high_G = 30.0              # G0
inter_G = 20.0              # G0
low_G = 10.0              # G0
piezo_speed_breaking1 = 300.0        # V/s
piezo_speed_breaking2 = 300.0        # V/s (30 to 300) Este es el que se puede cambiar
piezo_speed_making = 500.0        # V/s
#post_breaking_voltage = 230.0       #
post_breaking_voltage = 300.0       # cambia cuanto abro despues de que rompo
nGbins = 251
nDbins = 161
xmin = -0.5 # nm
xmax = 2    # nm
Gmin = 1e-7 # G0
Gmax = 10   # G0
#+END_SRC

***** TODO UI - Presentation
#+name: ui-presentation-params-defaults
#+BEGIN_SRC python :exports none
todoJUNCTURE_VOLTAGE_DFLT = 0  #[V]
todoPIEZO_SPEED_DFLT = 0       #[V/S]
todoDATA_DIRECTORY_DFTL = "./Data"
#+END_SRC

#+BEGIN_SRC python
  class presentation:
        def __init__(self):
              self.asdf = 1
#+END_SRC

#+NAME: ui-config-pp-interface
#+BEGIN_SRC python

#+END_SRC

*** TODO UI - GUI
   :PROPERTIES:
   :tangle:   modules/ui_gui.py
   :END:
# As with any module there is a section for the imports and the file headers, but these are unninteresting for any reader, thus they are put in comments and not exported to a PDF/HTML result
#+BEGIN_SRC python :exports none
  #################################################################
  ## @file    ui_gui.py
  #  @author  Joaquin Figueroa
  #  @date    Fri Aug 12 2016
  #  @brief   Provides the GUI for configuring the experiment
  #
  #  @details This file provides a GUI for the user to be able to
  #           configure the experiment and run it.
  #################################################################
  from PyQt4 import QtGui
  from PyQt4 import QtCore
  import ui_config as conf
  import sys
  <<ui-basic-params-defaults>>
  <<ui-advanced-params-defaults>>
  <<ui-presentation-params-defaults>>
#+END_SRC

The Graphical user interface consist of a window that allows the user to tweak with each of the parameters defined in [[UI - Program Interface]], plus buttons for deciding which action to take.

This program uses [[https://wiki.python.org/moin/PyQt][PyQt4]] as a GUI framework. To run a GUI, first is necessary to create an "application", then instantiate a widget, which corresponds to the specific UI that is being implemented to finally "execute" the "application". For a reference on how this is done under PyQt a tutorial can be found on [[http://zetcode.com/gui/pyqt4/]].

#+BEGIN_SRC python
  ############################################################
  ## @brief   Runs the GUI for the program
  ############################################################
  def run_gui():
      app = QtGui.QApplication(sys.argv) # Create "aplication"
      config_window = ui_config_window() # Instantiate widget
      app.exec_()                        # Execute appliaction
      return config_window.ui_config
#+END_SRC

**** TODO Configuration Window

The configuration window, shown in [[gui-config-window]] is a python widget which represents the user interface of the program. As usual with user interfaces they require an large amount of code only to initialize it where is difficult to separate the functionality. 

The standard procedure in python to build a widget is to delegate the initialization code to the parent class, and the UI elements specific to it, such as the buttons are defined in an internal initialization function of the class, commonly named =initUI= in line [[(fn-initUI)]]

The window object is composed of 3 basic elements:
- Config :: The contents of the window used to store and pass the configuration to the rest of the program shown in line [[(ui-config)]]
- Buttons ::  The UI has a button for each action including the measurements strategies to be used and to exit the program shown in line [[(ui-buttons)]]. For details see [[Buttons Layout]]
- Configuration :: The forms used to configure the parameters of the run defined in line [[(ui-config)]]. For details see [[Configuration Parameters Layout]]

Obviously as an object it also provides functionality to interact with it, mainly through the buttons of it, the idea is that only the window can modify it as to keep the interface as clean as possible.

The widget provides a callback defined in line [[(ui-close-cb)]] to be used by the buttons which will close the widget and ensure that the selected command, for example to measure, is executed
#+CAPTION: Definition of the configuration window
#+NAME: gui-config-window
#+BEGIN_SRC python -n -r
  ############################################################
  ## @class   ui_config_window
  #  @brief   Provides The UI window for the program
  #
  #  @details This Object provides the user interface to
  #           configure the measurements and which procedures
  #           to take.
  #           The object has the description of the window
  #           composed by the text dialogs and the buttons
  #           to run the simulation, which are stored as
  #           part of the window. The object also provides
  #           the functions to interface it.
  #           - initUI: Initialize the window
  ############################################################
  class ui_config_window(QtGui.QWidget):
      # Default constructor
      def __init__(self):
          super(ui_config_window, self).__init__()
          self.initUI()

      ############################################################
      ## @brief   Initializes the window
      #  @details Initialized the window components, which are the
      #           configs, the buttons and the configuration.
      #           Also ensures the layout of the UI elements
      ############################################################
      def initUI(self):    #(ref:fn-initUI)
          self.ui_config = conf.UI_CONFIG() #(ref:ui-config)

          buttons_layout = ui_create_buttons_layout(self) #(ref:ui-buttons)
          config_layout  = ui_create_config_layout(self)  #(ref:ui-config)
          vbox = QtGui.QVBoxLayout()
          vbox.addStretch(1)
          vbox.addLayout(config_layout)
          vbox.addLayout(buttons_layout)

          self.setLayout(vbox)
          self.setGeometry(300, 300, 300, 150)
          self.setWindowTitle('Buttons')
          self.show()

      ############################################################
      ## @brief   Interface to close the window and excecute a
      #           command
      ############################################################
      def close_with_cmd(self, cmd): #(ref:ui-close-cb)
          self.ui_config.update_cmd(cmd)
          QtCore.QCoreApplication.instance().quit()
#+END_SRC
**** TODO Buttons Layout
The buttons provide the functionality to launch the different process of the tool. Therefore clicking a button will close the UI and excecute the action stated on it. Also a small tooltip is provided in case the user requires additional information.

To define a button, first it must be created using the text to be displayed, then the attributes associated to it, meaning the action it will perform and the tooltip displayed, if any.
A special mention is made for the callback used in each button as it uses anonymous functions as shown in line [[(lambda_btn)]] to call the function that excecutes the corresponding action. While a more advanced programming technique (see [[https://en.wikipedia.org/wiki/Anonymous_function]]) it provides the cleanest and easiest method to provide this functionality (See also [[http://stackoverflow.com/questions/15080731/call-a-function-when-a-button-is-pressed-pyqt]])

Finally the buttons created are added to the layout of the button section of the window which is returned to the user.
#+BEGIN_SRC python -r -n
  ############################################################
  ## @brief   Creates buttons layout and returns it
  #
  #  @details The function creates a layout to place the
  #           buttons to perform the different actions of the
  #           program.
  #           The layout creates the following buttons:
  #           - Quit Button: Ends the program
  #           - Break Button: Use the motor do break junction
  #           - Measure Button: Do a break junction and then
  #                             use the piezo to measure
  ############################################################
  def ui_create_buttons_layout(widget):
      # Quit Button
      quit_button = QtGui.QPushButton("Quit")
      quit_button.clicked.connect(
          lambda: widget.close_with_cmd(conf.UI_CMD.EXIT)) (ref:lambda_btn)
      quit_button.setToolTip("Terminates the program")
      # Break Button
      break_button = QtGui.QPushButton("Only break")
      break_button.clicked.connect(
          lambda: widget.close_with_cmd(conf.UI_CMD.M_BREAK))
      break_button.setToolTip("Use the motor to create a break junction.")
      # Measure Button
      measure_button = QtGui.QPushButton("Full Measure")
      measure_button.clicked.connect(
          lambda: widget.close_with_cmd(conf.UI_CMD.MEASURE))
      measure_button.setToolTip(
          "Performs measurement using the motor and piezo")

      # Build Layout
      hbox = QtGui.QHBoxLayout()
      hbox.addStretch(1)
      hbox.addWidget(quit_button)
      hbox.addWidget(break_button)
      hbox.addWidget(measure_button)

      vbox = QtGui.QVBoxLayout()
      vbox.addStretch(1)
      vbox.addLayout(hbox)
      return vbox
#+END_SRC

**** TODO Configuration Parameters Layout
Since the configuration parameters are split in different groups so it is the layout of the configuration window, leaving a vertical section of the window to each group. The top level of the configuration parameters layout is shown in [[config-param-layout]], using the same techniques already used for the buttons. The rest of the description of the configuration parameters GUI is described in different sections:

- Basic parameters :: The layout for the basic parameters is described in [[Basic parameters layout]]
- Advanced parameters :: The layout for the advanced parameters is described in [[Advanced parameters layout]]
- Presentation parameters :: The layout for the presentation parameters is described in [[Presentation parameters layout]]
- Utilities :: Some utilities shared by all the different layouts are described in [[Configuration parameters layout utilities]]

#+CAPTION: Configuration parameters layout
#+NAME: config-param-layout
#+BEGIN_SRC python
  ############################################################
  ## @brief   Describes the configuration parameters layout
  #
  #  @details This function provides the layout for the portion
  #           of the window that allows the user to configure
  #           the parameters for the run.
  #           The layout is split in 3 vertical sections one
  #           with each parameter group.
  #           Each group is preceded by a small label
  #           identifying the group
  ############################################################
  def ui_create_config_layout(ui_config_window):
      # Define each group layout
      basic_param_layout = ui_basic_param_layout(ui_config_window)
      adv_param_layout = ui_adv_param_layout(ui_config_window)
      presentation_param_layout = ui_presentation_param_layout(ui_config_window)
      # Define the labels
      basic_label = QtGui.QLabel("---- Basic Parameters ----")
      adv_label = QtGui.QLabel("---- Advanced Parameters ----")
      presentation_label = QtGui.QLabel("---- Presentation Parameters ----")
      # Configure the layout
      vbox = QtGui.QVBoxLayout()
      vbox.addStretch(1)
      vbox.addWidget(basic_label)
      vbox.addLayout(basic_param_layout)
      vbox.addWidget(adv_label)
      vbox.addLayout(adv_param_layout)
      vbox.addWidget(presentation_label)
      vbox.addLayout(presentation_param_layout)
      return vbox
#+END_SRC

***** TODO Basic parameters layout
#+BEGIN_SRC python
  def ui_basic_param_layout(window):
      basic_params = window.ui_config.config._b_params ## Fix this
      # Num parameters fields
      jv_label, jv_text = num_param_label_textbox(basic_params.juncture)
      ps_label, ps_text = num_param_label_textbox(basic_params.piezo_speed)
      tr_label, tr_text = num_param_label_textbox(basic_params.traces)
      # Change directory dialog and fields
      dir_label = QtGui.QLabel(basic_params.data_dir.path)
      dir_btn = QtGui.QPushButton('Change Directory')
      dir_btn.clicked.connect(lambda: showDialog(window,dir_label))
      # Add fields to the layout
      grid = QtGui.QGridLayout()
      grid.setSpacing(10)

      grid.addWidget(jv_label,1,0)
      grid.addWidget(jv_text,1,1)

      grid.addWidget(ps_label,2,0)
      grid.addWidget(ps_text,2,1)

      grid.addWidget(tr_label,3,0)
      grid.addWidget(tr_text,3,1)

      grid.addWidget(dir_label,4,0)
      grid.addWidget(dir_btn,4,1)

      return grid
#+END_SRC

***** TODO Advanced parameters layout

***** TODO Presentation parameters layout
#+BEGIN_SRC python

  def ui_adv_param_layout(window):
      return ui_basic_param_layout(window)

  def ui_presentation_param_layout(window):
      return ui_basic_param_layout(window)

#+END_SRC

***** TODO Configuration parameters layout utilities
As previously stated, some of the functionalities that are required to describe a configuration parameter layout are too complex to be described clearly within each parameter layout, and these are common, so in order to keep the code and the structure as simple as possible, these functionalities are described separately. The utilities are:
- Parameter validator :: Most parameters are numerical, and the functionality described in [[Numerical parameter validator]], ensures that the user does not enter invalid values
- Parameter label creator :: Parameters that are entered through a text-box, have the same functionality, which only depends on the parameter at hand. The functionality described in  [[Parameter labels]] creates the labels based only on the parameter
- Change directory dialog :: A simple functionality to show the change directory dialog to the user is described in [[Change directory dialog]]

****** DONE Numerical parameter validator
The GUI is described using PyQt, which provides a mechanism to ensure that no invalid values are written or stored in the different txet-boxes. This mechanism is provided through the definition of a specialization of the [[http://doc.qt.io/qt-4.8/qvalidator.html][QValidator Class]], as shown in [[src-qvalidator-num-param]].

The overloading is performed by adding a parameter to the validator in the initialization function shown in line [[(src-qvalidator-np-init)]]. Then the =validate= function is overloaded by leveraging the =validate= function of the parameter as shown in the line [[(src-qvalidator-np-val)]], and allowing only values that are valid for the parameter.

#+CAPTION: QValidator specialization for numerical parameters
#+NAME: src-qvalidator-num-param
#+BEGIN_SRC python -n -r
  #############################################################
  ## @class   QValidator_num_param
  #  @brief   Validator for numerical parameters
  #
  #  @details This class provides a specialization of the
  #           QValidator class for numerical parameters and
  #           allow only values that are valid for the
  #           parameter.
  #############################################################
  class QValidator_num_param(QtGui.QValidator):
          #############################################################
          ## @brief   Initialization function, with the parameter
          #############################################################
          def __init__(self, param): #(ref:src-qvalidator-np-init)
              QtGui.QValidator.__init__(self)
              self.param = param
          #############################################################
          ## @brief   Validate function using the parameter validation
          #           Ensures data is a number.
          #############################################################
          def validate(self, text, pos):#(ref:src-qvalidator-np-val)
                  try:
                          num = float(text)
                  except ValueError:
                          return (QtGui.QValidator.Invalid, pos)

                  if self.param.validate(num):
                          self.param.update(num)
                          return (QtGui.QValidator.Acceptable, pos)
                  return (QtGui.QValidator.Invalid, pos)
#+END_SRC

****** TODO Parameter labels
To provide the GUI for a parameter, a label and a text-box are needed, however for numerical parameters, the only difference between a set is the parameter, therefore a function is created that create both based only on a specific parameter.

#+BEGIN_SRC python
  #############################################################
  ## @brief   Creates a label and textbox for a numerical
  #           parameter.
  #############################################################
  def num_param_label_textbox(parameter):
      label = QtGui.QLabel(parameter.name)
      textbox = QtGui.QLineEdit()
      param_validator = QValidator_num_param(parameter)
      textbox.setValidator(param_validator)
      textbox.setText(str(parameter.value))
      return (label, textbox)
#+END_SRC

****** Change directory dialog
#+BEGIN_SRC python
  def showDialog(window,dir_label):
      data_dir = window.ui_config.config._b_params.data_dir
      fname = QtGui.QFileDialog.getExistingDirectory(window, 'Open file',
              data_dir.path)
      data_dir.update(fname)
      dir_label.setText(data_dir.path)
      print(data_dir.path)
#+END_SRC

** TODO Motor break junction 
   :PROPERTIES:
   :tangle:   modules/motor_break.py
   :END:
#+BEGIN_SRC python
  def motor_break_juncture():
      print ("Picked Motor break")

#+END_SRC

** TODO Measurement with Piezo
   :PROPERTIES:
   :tangle:   modules/piezo_measure.py
   :END:
   
#+BEGIN_SRC python
  def measure_sample():
      print("Picked measure sample")

#+END_SRC

** TODO Instruments interface
The program has to interact with the mechanical actuators and the measurement instruments to perform the breaking of the juncture and measure the conductance. The program has only 2 "real-world" interfaces.
- Faulhaber Motor :: Is a motor, which controls the initial breaking of the juncture. The program then requires a simple interface to move the motor a given distance in order to open or close the juncture.
- ADwin :: The ADwin is a multipurpose instrument which is not only capable to taking measurements, but also provides the control for the piezoelectric actuator, and the other parameters used in the experiment, thus the ADwin interface is by necessity more complex as it has to deal with far more phenomena.

*** Faulhaber Interface
*** TODO Adwin Interface
    :PROPERTIES:
    :tangle:   modules/ADwin_interface.py
    :noweb:    tangle
    :comments: link
    :END:
According to the ADwin manual, the instrument provides with 3 data groups to transfer data between the instrument and the computer. Each data group is indexed and can be accessed by using the corresponding interface. 
To properly work with the ADwin, 2 interfaces are needed. 
- Hardware Interface :: Describes how to interact with the hardware by itself. Fortunately it has been mostly taken care of by the Python bindings
- Program Interface :: Obviously is not a good idea to interact directly with the instrument, so a second layer is used to provide abstraction so the actual queries are meaningful in the context of the program.

There is also the need to define which ADwin variable corresponds to the interest variables for the program.
**** ADwin Data indices
The ADwin instrument holds several variables which can be interfaced with the program, and the program  uses the different indices and data groups for different purposes [fn:: which as far as I can, tell the correspondence is defined in the process files which are binary files so I can't confirm it], therefore the parameters are indexed with meaningful names according to their intended purpose.
***** Adwin Juncture Voltage
#+BEGIN_SRC python
  class juncture_v_idx:
#+END_SRC

 #+BEGIN_SRC python :tangle no
   # Index of analyzed parameters. In progress .
   class adwin_params:
       p_start_v = 7    # Start_voltage
       p_set_v   = 8    # Set Voltage
       p_end_v   = 9    # End Voltage
       p_length_v = 57  # Length of voltage array ?
       p_average_v = 55 # Number of points to average
       p_settling_time = 56 # Settling time
       p_proces_status = 59 # Process status
       p_bin_current = 70 # Current in binary ?
       p_current_v = 8  # Current for voltage ?
       p_runtime_total = 10 # Total runtime ->similar to 57 ?
       p_time_get = 11 # Parameter to get current time ? -> array?
       f_current  = 14 # Temporary current (seems not used)
       f_bin_current = 12 # Current as a binary number ?
       p_gate_voltage_start = 31 # Gate start voltage
       p_gate_voltage = 32 # gate voltage
       p_gate_voltage_end = 33 # gate voltage end
       p_settling_gate = 34 # Settling time for gate voltage
       p_runtime = 38 # Set runtime -> for gate ?
       p_gate_status = 39 # Gate process status ?
       p_voltage_current = 8 # Voltage current. Seems unused
       f_current_high = 20 # High current parameter
       f_current_intermediate = 21 # Intermediate current parameter
       f_current_low = 20 # Low current parameter
       p_break_wait_piezo =23 # Cycles to wait piezo 1
       p_break_wait_piezo2 =24 # Cycles to wait piezo 2. unsue differece with 23
       p_make_wait_piezo =25 # Cycles to wait piezo for making
       p_wait_post = 26 # Cicles to wait after breaking ?
       p_program = 60 # Adwin crash status ?
       p_length_breaking = 2 # Number of data points in breaking
       p_length_making = 3 # Number of data points in making
       p_process_type = 4 # Determine which process type is running ?
 #+END_SRC

* Utility functions
This section is for the interface with each measurement instrument.


* Settings                                                         :noexport:
#+BEGIN_SRC emacs-lisp :export none :results none
(setq org-babel-use-quick-and-dirty-noweb-expansion t)
(org-babel-do-load-languages
 'org-babel-load-languages
 '((python . t)
   ))
(setq org-babel-python-command "/bin/python2")
#+END_SRC

** colorize
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-latex-packages-alist '("" "listings"))
  (setq org-latex-listings t)
#+END_SRC

#+RESULTS:
: t



