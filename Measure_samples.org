#+OPTIONS: ':nil *:t -:t ::t <:t H:8 \n:nil ^:nil arch:headline
#+OPTIONS: author:t broken-links:mark c:nil creator:nil
#+OPTIONS: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+OPTIONS: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+OPTIONS: timestamp:t title:t toc:t todo:t |:t
#+TITLE: Measure_samples
#+DATE: <2017-01-03 Tue>
#+AUTHOR:
#+EMAIL: joaquin@joaquin_laptop
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 25.1.1 (Org mode 9.0.3)

#+LATEX_CLASS: book
#+LATEX_CLASS_OPTIONS:
#+LATEX_HEADER:
#+LATEX_HEADER_EXTRA:
#+DESCRIPTION:
#+KEYWORDS:
#+SUBTITLE:
#+LATEX_COMPILER: pdflatex

#+OPTIONS: html-link-use-abs-url:nil html-postamble:auto
#+OPTIONS: html-preamble:t html-scripts:t html-style:t
#+OPTIONS: html5-fancy:nil tex:t
#+HTML_DOCTYPE: xhtml-strict
#+HTML_CONTAINER: div
#+DESCRIPTION:
#+KEYWORDS:
#+HTML_LINK_HOME:
#+HTML_LINK_UP:
#+HTML_MATHJAX:
#+HTML_HEAD:
#+HTML_HEAD_EXTRA:
#+SUBTITLE:
#+INFOJS_OPT:
#+CREATOR: <a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.1.1 (<a href="http://orgmode.org">Org</a> mode 9.0.3)
#+LATEX_HEADER:




* Introduction
This file is a try to document and enhance the program in python to measure the samples through the mechanism of of break-junction in gold samples for the study of molecular properties.
The reason for this is that the current program, while functional is under-documented and the full how-to is preserved through *oral tradition* which is regrettable for an investigation lab, and since the author of this document has a bit of experience in software development and documentation, this file was born.

** Break Junction
The experiment is to measure the break junction

**  Actuators and measuremnts
The program uses 2 different mechanical actuators to perform the measurements, and there are 2 different kind of samples to be measured. Finally the measurement is performed by analyzing the conductance of the sample.

*** Mechanical actuators
Since the experiment is based on a single gold "nano-wire"  which is broken through mechanical means, there is need for mechanical acutators to beak the "wire" to measure the conductance change.

**** Faulhaber Motor
The Faulhaber motor is used to perform relatively large movements on the sample and is used to break the sample initially

**** Piezo actuator
Once the junction is broken, the motor is turned off and the piezo-device is used, since it provides a simple controllable way to perform even samller movements on the piece for the study

*** Samples types
Even though the experiment is always performed over gold "wires", there are 2 distinct clasification of the samples.
# So far it seems (to me) that regardless of the type of measurement the mechanism is the same
**** Clean gold
Since the gold is the sustrate, is measured to ensure that is clean and there are no impurities prior to a real measurement

**** Gold + Molecule
The focus of the experiment is to measure the transport (conductance) properties of a given molecule, thus once a gold sustrate has been measured and confirmed to be usable, a molecule solution is placed on the sustrate with the expectation that a molecule gets inserted in the gap between the gold terminals.

*** ADWin measurement
The measurement of the conductance is performed using the ADWin board which has an interface and binding to python. The documentation for the ADWin measurement instrument can be found on the [[http://www.adwin.de/us/download/linux.html][Download page]]

Since the objective is to measure the transport properties, the most important parameters to measure are the conductance and the separation between the gold contacts (break junction)

* Program Description
  :PROPERTIES:
  :header-args+: :comments noweb
  :END:


As it was already stated the measurement is splitted in 2 steps, the motor initialization and the piezo measurement, however a full program cannot be limited to these 2 steps, as there are additional requirements uch as a user interface for the program. Thus the program is organized as:
- Main loop :: As in many programs the main loop is the one that orchestrates the execution of the program. For details see [[Main Loop]]
- UI Interface :: Considering the requiremens for different configurations for the measurement such as the voltage applied to the juncture, there is a requierement for a reasonable to use UI, and this UI should allow the user to run a measurement. For details see [[User Interface]]
- motor break :: Using the motor actuator, a break juncture is created and then the displacement is set so that a movement generated with the piezo-electric actuator the juncture can be easily reconstructed. For details see [[Motor break junction]]
- Measurement with the piezo :: With the sample in the optimal setting for the piezo is the measured by modifying the voltage applied to the piezo-electric device which in turn creates a displacement of the sample recreating the juncture an allowing for easily repetable measurements through the dynamic range of the piezo-electric device. For details see [[Measurement with Piezo]]

Obviously there is a series of additional modules which provide the interface to the different actuators, and additional helpeer functions to improve the presentation of the results, all of which will be presented in turn.

** DONE Main Loop
   :PROPERTIES:
   :header-args+:  :tangle   main.py
   :END:
#+BEGIN_SRC python :exports none
  #################################################################
  ## @file    Main.py
  #  @author  Joaquin Figueroa
  #  @brief   Main file for measuring break-junction experiments
  #
  #  @details This is the main file for the program used to
  #           measure samples using the break-junction technique.
  #           This program provides a GUI to control the execution
  #           based on providing the tools to configure a run.
  #           The program automates the whole procedure by:
  #           1- Automating the creation of the break junction
  #           using the motor
  #           2- Automating the measurement process using a piezo
  #           actuator.
  #################################################################
#+END_SRC
As with many considerable programs this one stars importing the necesary files. In this case, all the modules imported for the main file come from the modules created for the program.
#+BEGIN_SRC python
  import sys
  from modules.ui_config import *
  from modules.motor_break import *
  from modules.piezo_measure import *
#+END_SRC

The main loop is indeed a loop. It is intended to work in the following way.
- First the UI is presented to the user, so the user can modify the configuration of the experiment. As a result from the UI execution there are 3 possible outcomes:
  1. Exit the program
     #+BEGIN_SRC python
       ############################################################
       ## @fn    : main_exit
       #  @brief : Terminates program execution
       ############################################################
       def main_exit(config) :
           print("Program Finished successfully")
           sys.exit()
     #+END_SRC
  2. Excecute only the junction creation. This is to prepare a clean sample, since there is no benefit to measure using the piezo a clean sample
     #+BEGIN_SRC python
       ############################################################
       ## @fn      : main_motor_break
       #  @details : Commands the motor to break the gold channel
       #             creating a break-junction and then joins it
       #             again leaving it ready for measurement
       ############################################################
       def main_motor_break(config):
           motor_break_juncture()
     #+END_SRC
  3. Execute a full measurement, creating the juncture and then measure the molecule
     #+BEGIN_SRC python
       ############################################################
       ## @fn      : main_measure
       #  @details : Measures the transport properties of the
       #             sample by creating the break-junction with the
       #             motor, and using the piezo to measure
       ############################################################
       def main_measure(config):
           motor_break_juncture()
           measure_sample()
     #+END_SRC

The outcome picked by the user must be translated into a command in the program, this is performed in a similar way as a switch-case, but in python is implemented as a dictionary test, which may seem odd for someone not used to the technique. For reference please see [[http://www.pydanny.com/why-doesnt-python-have-switch-case.html][switch-case in python.]]
#+BEGIN_SRC python
  ############################################################
  ## @fn      : execute_ui_cmd
  #  @details : Analyzed the command chosen by the user and
  #             executes it. Options are:
  #             1- End program
  #             2- only perform break-junction
  #             3- perform full measurement of the sample
  ############################################################
  def execute_ui_cmd(ui_cmd,config) :
      switch = {
          UI_CMD.EXIT    : main_exit,
          UI_CMD.M_BREAK : main_motor_break,
          UI_CMD.MEASURE : main_measure,
      }
      cmd = switch.get(ui_cmd, sys.exit)
      cmd(config)
#+END_SRC

Finally the main loop is executed indefinitely until the user terminates the program

#+BEGIN_SRC python
  ############################################################
  ## @details : Main loop. Executes UI Cmd until the user end
  ##            the program
  ############################################################
  def main():
      while True :
          ui_config = ui_get_gui_config()
          ui_cmd    = ui_config.cmd
          config    = ui_config.config
          config._b_params.print_all()
          execute_ui_cmd(ui_cmd,config)

  if __name__ == "__main__":
      main()
#+END_SRC

** TODO User Interface
   :PROPERTIES:
   :header-args+:  :noweb    tangle
   :END:
The user interface has 2 requirements.
1. It should allow the user to run the experiment
2. It should allow the user to tweak with the configuration for the experiment

Now there is an additional requirement for the UI, which is the interface by itself, is related to the configuration, and the different measurement process available. Up to this point we have 3 main purposes:
1. Histogram measurement of the conductance/distance characteristic of the molecule
2. Display the measurements, which is used during measurements as feedback for the process and allows an advance user to judge the state of the experiment
3. intermediate measurements which are measurements of the I/V characteristics of the sample and are used in the experiment to drive the program to the starting point as it was discussed in [[Program Description]].

With this into consideration I have decided to provide with 2 distinct interfaces for the program:
- Configuration files :: Configuration files are the standard direct way of configuring the behavior of a program, and if done properly is easier to extend and adapt.
- GUI :: A graphical user interface will be provided for user that may not have an interest in tweaking with the configuration files, the purpose of the GUI is to automatically  generate the corresponding configuration files through a relatively more intuitive interface. Considering that GUI programming is harder, it may be possible that another programmer may find the task of extending the GUI to daunting, which is the reason for this dual approach instead of simply using a GUI directly.

Now I will provide a slightly more detailed view of the UI directives, leaving in depth description to the corresponding sections.

As previously discussed, there are several parameters to tweak, which can be modified with a configuration file that is written in use [[http://www.yaml.org][YAML]], for its simplicity for the user, and corresponding library availability for python which allows for simple interfaces for readers and writers of the configuration file.

The configuration file will be read and used to create a *configuration structure* (See [[Program Configuration-Process configurations]] ), which has the configurations for each of the configurable processes in a *Sub-configuration* manner.

For each configurable process, we easily identify 2 types of parameters:
- Configurable parameters :: These are the parameters that are modified through the Configuration file. Even though the user may modify these values, the parameters can't be set to any arbitrary value, therefore there is a mechanism to ensure that the values may never exceed some hardcoded limits. See  [[Parameters definitions]]
- Non Configurable parameters :: This are parameters, that are needed for running the different processes, but should not be tampered by the user, and therefore are hard-coded in the program.

On the other hand, it was mentioned that the GUI will build a configuration file for use of the rest of the program, therefore a Writer function is needed for a configuration, so the *YAML* can be written. Naturally the easiest way to achieve such functionality is to tie it directly to the same configuration, therefore the GUI would be building a configuration in order to write the configuration file. At first glance this may seem redundant, but allows for planning of multiple builds or even ensuring the exact parameters of a particular run of the experiment, as the written file will be available for further inspection.

Considering the previous description, the User interface of the program can be separated in the following logical sections.

- Configuration :: As mentioned the configuration is the main objective of the configuration file and should be considered as a 2 part section. Further details can be seen in the [[Program Configuration]]
  - Configuration file :: Which is the definition of the configuration file, and therefore defines the configurable parameters
  - Configuration Class :: Which is the output of the configuration, and provides the configurations for every configurable process of the program.
- Parameters Definitions :: This section shown in  [[Parameters definitions]] has the necessary definitions to have a robust interface with the user defined variables. It also provides the definitions for the hardcoded constants and their manipulations
- GUI :: The Graphical User interface which will launch a application terminal for the user to tweak the different parameters and finally write a configuration file for further use.
*** TODO Program Configuration 
    :PROPERTIES:
    :header-args+: :tangle   modules/configuration.py
    :header-args+: :noweb    tangle
    :END:

The program configuration, is the interface that allows the user to modify the program's behavior through the use of configuration files; the functionality to do this is provided in the file  [[file:modules/parameters.py]]. This file provides:
- Configuration structures :: The configuration structures is a set of classes which are used to configure the different processes of the program. Further explained in [[Program Configuration-Process configurations]]
- Configuration File interface :: Provides with the functions required to interact with the configuration file, which means to read and write it. Also this section provides the specification for the file. Further details in [[Configuration Files]]

# Here we put the header
#+BEGIN_SRC python :exports none
  #################################################################
  ## @file    parameters.py
  #  @author  Joaquin Figueroa
  #  @dateMon Jan 16, 2017
  #  @brief   Defines configurable parameters and global constants
  #
  #  @details This file defines the configurable parameters of the
  #           program with their corresponding interfaces and
  #           validations.
  #           Also the program provides the definitions of the
  #           global constants of the program
  #################################################################
  import modules.adwin_driver as adwin
  import modules.utilities as utl
  import modules.parameters as param
  import os
  import sys
  import yaml
#+END_SRC

**** TODO Program Configuration-Process configurations
This section is devoted to describe the configuration of the program, which is tied to the configuration file specification shown in [[Configuration Files specification]], but is also tied to the different processes which are used through the program for the different types of measurements that are defined in the [[ADwin Driver]].

In order to provide with the complete interface, the file is separated in:
- Full configuration :: Properly discussed in [[Full Configuration definition]]. This configuration is a large structure whose purpose is to serve a single return parameter of the different types of configuration. It also provides with some generic functionalities
- IV-Measurement Configuration :: Properly defined in [[IV-Measurement Configuration]]. This structures has the parameters required to perform the  IV-measurement as defined in [[Adwin driver-IV measurement class]]
- Histogram Measurements configuration ::  Properly defined in [[Histogram-Measurement Configuration]]. This structures has the parameters required to perform the  histogram measurements as defined in [[Adwin driver-histogram class]]
- Display Configuration :: Properly defined in [[Display Configuration]]. This structure has all the parameters needed to produce runtime graphics to display the results for the user to judge the quality of the results.

***** Full Configuration definition
The full configuration is the general interface for all configuratioins, as it encompasses them all.

#+BEGIN_SRC python
  class program_config:
      def __init__(self,data=None):
          iv_data = None
          hist_data = None
          display_data = None
          if data :
              iv_data = data.get('IV Configuration')
              hist_data = data.get('Histogram Configuration')
              display_data = data.get('Display Configuration')

          self.iv_config = iv_config(iv_data)
          self.hist_config = histogram_config(hist_data)
          self.display_config = histogram_config(display_data)
      def dump_config_file(self,filename = None):
          config = {}
          config['IV Configuration'] = self.iv_config
          config['Histogram Configuration'] = self.hist_config
          config['Display Configuration'] = self.display_config
        
#+END_SRC

***** IV-Measurement Configuration
#+BEGIN_SRC python
  class iv_config:
      def __init__(self,data=None):
          self.build_config_dflt()
          if data :
              self.update_config_with_data(data)

      def build_config_dflt(self):
          self.measure_jv = param.juncture_voltage()
          self.log_ampl = adwin.adwin_log_amplifier()
          self.avg_points = param.avg_points()
          self.wait = param.GLOBAL_CONSTANTS.IV_settling_time
          self.start_jv = param.GLOBAL_CONSTANTS.start_jv
          self.end_jv = param.GLOBAL_CONSTANTS.end_jv
          self.max_data = param.GLOBAL_CONSTANTS.IV_max_data_points
          self.g0 = param.GLOBAL_CONSTANTS.G0
          self.config = {}
          self.update_config()

      def update_config(self):
          self.config['JunctureVoltage'] = self.measure_jv.value
          self.config['AveragePoints'] = self.avg_points.value

      def update_config_with_data(data):
          self.measure_jv.update_or_dflt(data.get('JunctureVoltage'))
          self.avg_points.update_or_dflt(data.get('AveragePoints'))
          self.update_config()

      def convert_to_adwin(self):
          adwin_measure_jv = adwin.adwin_ADC(self.measure_jv.value)
          measure_jv.update(convert_bin_to_V(adwin_measure_jv))

      def get_log_array(self):
          return self.log_ampl.get_calibration()
      def get_start_jv(self):
          return adwin.adwin_ADC_value(self.start_jv)
      def get_measure_jv(self):
          return adwin.adwin_ADC_value(self.measure_jv.value)
      def get_stop_jv(self):
          return adwin.adwin_ADC_value(self.stop_jv)
      def get_avg_points(self):
          return self.avg_points.value
      def get_start_jv(self):
          return adwin.adwin_ADC_value(self.stop_jv)

      def get_wait_cycles(self):
          return adwin.adwin_convert_ms_to_cycles(self.wait)
      def get_max_data(self):
          return self.max_data
      def get_real_jv(self):
          return adwin.adwin_DAC_value(sef.get_measure_jv())
      def get_use_log_ampl(self):
          return True
#+END_SRC

***** Histogram-Measurement Configuration
#+BEGIN_SRC python
  class hist_config:
      def __init__(self,data=None):
          self.build_config_dflt()
          if data :
              self.update_config_with_data(data)

      def build_config_dflt(self):
          self.measure_jv = param.juncture_voltage()
          self.start_jv = param.GLOBAL_CONSTANTS.start_jv
          self.end_jv = param.GLOBAL_CONSTANTS.end_jv
          self.log_ampl = adwin.adwin_log_amplifier()
          self.avg_points = param.avg_points()
          self.break_speed = param.break_speed()
          self.make_speed = param.make_speed()
          self.traces = param.traces()
          self.save_dir = param.save_dir()
          self.save_data = param.data_dir()
          self.G0 = param.GLOBAL_CONSTANTS.G0
          self.G_open = 1e-5 * self.G0
          self.G_closed =  2 * self.G0
          self.config = {}
          self.update_config()

      def update_config(self):
          self.config['JunctureVoltage'] = self.measure_jv.value
          self.config['AveragePoints'] = self.avg_points.value
          self.config['BreakSpeed'] = self.break_speed.value
          self.config['MakeSpeed'] = self.make_speed.value
          self.config['NumberTraces'] = self.traces.value
          self.config['SaveData'] = self.save_data.value
          self.config['SaveDir'] = self.data_dir.path

      def update_config_with_data(data):
          self.measure_jv.update_or_dflt(data.get('JunctureVoltage'))
          self.avg_points.update_or_dflt(data.get('AveragePoints'))
          self.break_speed.update_or_dflt(data.get('BreakSpeed'))
          self.make_speed.update_or_dflt(data.get('MakeSpeed'))
          self.traces.update_or_dflt(data.get('NumberTraces'))
          self.data_dir.update(data.get('SaveDir'))
          self.save_data.update(data.get('SaveData'))
          self.update_config()
        
      def convert_to_adwin(self):
          adwin_measure_jv = convert_V_to_bin(self.measure_jv.value)
          measure_jv.update(convert_bin_to_V(adwin_measure_jv))

      def get_log_array(self):
          return self.log_ampl.get_calibration()
      def get_start_jv(self):
          return adwin.adwin_ADC_value(self.start_jv)
      def get_measure_jv(self):
          return adwin.adwin_ADC_value(self.measure_jv.value)
      def get_stop_jv(self):
          return adwin.adwin_ADC_value(self.stop_jv)
      def get_avg_points(self):
          return self.avg_points.value

      def get_max_data(self):
          return self.max_data
      def get_real_jv(self):
          return adwin.adwin_DAC_value(sef.get_measure_jv())
      def get_use_log_ampl(self):
          return True
      def get_break_wait(self):
          break_speed = self.break_speed.value
          # We are taking 0->1000 to 0->10, because that's the Adwin range
          break_steps = adwin_ADC(break_speed/100) *1e-3 # in ms
          break_wait =  1/break_steps
          return adwin.adwin_convert_ms_to_cycles(break_steps)
      def get_make_wait(self):
          make_speed = self.make_speed.value
          # We are taking 0->1000 to 0->10, because that's the Adwin range
          make_steps = adwin.adwin_ADC(make_speed/100) *1e-3 # in ms
          make_wait =  1/make_steps
          return adwin.adwin_convert_ms_to_cycles(make_steps)
      def get_I_break_end(self):
          return  self.G_break_end*self.get_real_jv()
      def get_I_make_end(self):
          return  self.G_make_end*self.get_real_jv()

#+END_SRC

***** Display Configuration
#+BEGIN_SRC python
  class display_config:
      def __init__(self,data=None):
          self.build_config_dflt()
          if data :
              self.update_config_with_data(data)

      def build_config_dflt(self):
          self.xmin = display_xmin()
          self.xmax = display_xmax()
          self.Gmin = display_Gmin()
          self.Gmax = display_Gmax()
          self.nGbins = display_nGbins()
          self.nDbins = display_nDbins()
          self.config = {}
          self.update_config()


      def update_config(self):
          self.config['xmin'] = self.xmin.value
          self.config['xmax'] = self.xmax.value
          self.config['Gmin'] = self.Gmin.value
          self.config['Gmax'] = self.Gmax.value
          self.config['nGbins'] = self.nGbins.value
          self.config['nDbins'] = self.nDbins.value

      def update_config_with_data(data):
          self.xmin.update_or_dflt(data.get('xmin'))
          self.xmax.update_or_dflt(data.get('xmax'))
          self.Gmin.update_or_dflt(data.get('Gmin'))
          self.Gmax.update_or_dflt(data.get('Gmax'))
          self.nGbins.update_or_dflt(data.get('nGbins'))
          self.nDbins.update_or_dflt(data.get('nDbins'))

          self.update_config()

      def get_xmin(self):
          return self.xmin.value
      def get_xmax(self):
          return self.xmax.value
      def get_Gmin(self):
          return self.Gmin.value
      def get_Gmax(self):
          return self.Gmax.value
      def get_nGbins(self):
          return self.nGbins.value
      def get_nDbins(self):
          return self.nDbins.value
#+END_SRC

***** File Interface

 Since the program will be configured through a configuration file, it only makes sense to provide with a writer and a parser for it. Fortunately we already have most of the heavy-lifting done by YAML libraries and the parameters configurations in the UI-interface part of the program, I'd expect this part to be relatively easy to understand.

 #+BEGIN_SRC python
   def yaml_loader(filepath):
       with open(filepath, "r") as file_descriptor:
           data = yaml.safe_load(file_descriptor)
       return data

   def yaml_dump(filepath, data):
       with open(filepath, "w") as file_descriptor:
           yaml.dump(data, file_descriptor,  default_flow_style = False, allow_unicode = True) 

   def yaml_build_config_from_file(filepath):
       data = yaml_loader(filepath)
       return program_config(data)
#+END_SRC

****** Testing                                                     :noexport:
    :PROPERTIES:
    :header-args+: :tangle   no
    :header-args+: :noweb    tangle
    :END:

#+BEGIN_SRC python 
  from modules.configuration import *
  infile = "Measurement_deafult_config.yaml"
  outfile = "Measurement_read_config.yaml"
  config = yaml_build_config_from_file(infile)
  print config

#+END_SRC

#+RESULTS:

**** TODO Configuration Files
Following a more traditional UNIX approach, is a good idea to allow the program to be run from the command line, rather than forcing a GUI to the user. By using a configuration file, the user will be able to configure the run, and be sure that all parameters are correctly set beforehand, in a way that would allow for several runs automatically.

Also the introduction of configuration files does not mean that the program will do away with the GUI, rather that the GUI will generate the appropriate configuration file, to run  the program.

***** DONE Configuration Files specification
      :PROPERTIES:
      :header-args+: :tangle  Measurement_deafult_config.yaml
      :END:
 To specify the configuration, I've decided to use [[http://www.yaml.org][YAML]], which provides a relatively simple interface, and an appropriate parser for python, while also allowing comments.
 The configuration will be split in 3 parts.
 - IV Parameters :: These are variables that control the Adwin during the motor break process.
 - Histogram parameters :: The histogram is the measurement that the program is really interested on, therefore the user may need to modify some parameters
 - Presentation parameters :: During measurement the program will display the histogram to provide the user with feedback, therefore the user may need to modify some of these parameters to better suits his[fn:or her needs] needs

 That being said, we provide with an example configuration file. See [[http://www.yaml.org/spec/1.2/spec.html][YAML Specification]] or [[http://ess.khhq.net/wiki/YAML_Tutorial][YAML tutorial]]
 #+BEGIN_SRC yaml
   # Begin of configuration File
   ---
   IV Configuration :              # Continous measurement during motor break
     JunctureVoltage : 0.1         # Range 0.1-0.3
     AveragePoints : 32            # Number of points to average

   Histogram Configuration :
     JunctureVoltage : 0.1         # Range 0.1-0.3
     AveragePoints : 32            # Number of points to average
     BreakSpeed : 300              # Volts/s
     MakeSpeed : 500               # Volts/s
     NumberTraces : 5000            # Number of histograms
     # Where to save the Data
     SaveData: Yes
     DataDir : 'E:/Measurements/Fullerenos/C60 2/Molecule/'

   Display Configuration:
     xmin : -0.5                   # nm
     xmax : 2                      # nm
     Gmin : 1e-7                   # G0
     Gmax : 10                     # G0
     nGbins : 251                  # Slots for Conductance histogram
     nDbins : 161                  # Slots for Distance histogram
 #+END_SRC
*** TODO Parameters definitions
    :PROPERTIES:
    :header-args+: :tangle   modules/parameters.py
    :header-args+: :noweb    tangle
    :END:

As mentioned earlier, there are 2 basic types of parameters: Configurable, and  Non-Configurable. The non configurable parameters are global constants of the program.
The parameters are located in the file [[file:modules/parameters.py]], which has the minimum requirements for it to work.

# Here we put the header
#+BEGIN_SRC python :exports none
  #################################################################
  ## @file    parameters.py
  #  @author  Joaquin Figueroa
  #  @dateMon Jan 16, 2017
  #  @brief   Defines configurable parameters and global constants
  #
  #  @details This file defines the configurable parameters of the
  #           program with their corresponding interfaces and
  #           validations.
  #           Also the program provides the definitions of the
  #           global constants of the program
  #################################################################
  import modules.utilities as utl
  import os
  import sys
#+END_SRC

**** DONE Configurable parameters definitions
     For configurable parameters, is necessary to allow the user to set values within certain limits, either to avoid damaging the equipment, the sample or just to prevent measurement that would take months to complete.
     The proper way to allow users to set the values within a constrained range is to provide with validation code, and if necessary with error correction.
     Considering the configuration file definition shown in [[Configuration Files]], the *data directory* which is further discussed in [[Data directory]] is one of the few parameters that are not a number. It is noticed that all numeric parameters show some similarities and therefore are defined together in [[Numerical Parameters definition]]

     The Parameter that controls if the Data should be saved is defined in [[Histogram Save Data]]

***** DONE Histogram Save Data
The user may decide not to save the data, for example if is just checking the configuration and do not want to save the data as he will run the process again later.

#+CAPTION: Define if saving the data is necessary
#+NAME: src-config-save-data-class
#+BEGIN_SRC python
  #############################################################
  ## @class   save_data
  #  @brief   All functionality to the decition to save data
  #
  #  @details This class defines the parameter that controls
  #           if the data is stored 
  #           that codifies the directory, depending on the
  #           os and inspect modules
  #############################################################
  class save_data:
      #############################################################
      ## @brief   Initilaization code
      #############################################################
      def __init__(self):#(ref:src-dd-init)
          self.reset()
      ##############################################################
      ## @brief   restores the default value of the number of traces
      ##############################################################
      def reset(self): #(ref:src-dd-reset)
          self.value = True
      ##############################################################
      ## @brief   Ensures the new target string is a directory
      ##############################################################
      def validate(self, new_value):#(ref:src-dd-validation)
          return type(new_calue) is bool
      #############################################################
      ## @brief   Updates the target directory only if its a
      #           directory in the filesystem
      #############################################################
      def update(self, new_value):#(ref:src-dd-update)
          if self.validate(new_value):
              self.value = new_value
      #############################################################
      ## @brief   Print the parameter.
      #############################################################
      def print_param(self):#(ref:src-dd-print)
          print("Save Data is = {0}".format(self.value))

#+END_SRC
***** DONE Data directory
  The program provides the user with the ability to store the Data in a directory of his choice, which is stored as a string.
  The data directory parameter is defined in [[src-config-data-dir-class]], which provides the full interface for the data directory.

  - Initialization Function :: Defined at [[(src-dd-init)]]. This function uses the "reset" function
  - Reset function :: Defined at [[(src-dd-reset)]], this function restores the default data directory,  is chosen to be a "data" subdirectory of the program root directory.
  - Validation Function :: Defined at [[(src-dd-validation)]], this function returns true if the chosen path is a directory as recognyzed by the operative system.
  - Update functionality :: Defined at [[(src-dd-update)]], this function is used to change the data directory to a new chosen path in the computer.
  -  Printing function ::  Defined at [[(src-dd-print)]] and used mainly for debug purposes this function prints the chosen data directory to the console.

  #+CAPTION: Data directory parameter class
  #+NAME: src-config-data-dir-class
  #+BEGIN_SRC python -n -r
    #############################################################
    ## @class   traces
    #  @brief   All functionality related to the data directory
    #
    #  @details This class defines the parameter that controls
    #           where the results will be stored. Is a string
    #           that codifies the directory, depending on the
    #           os and inspect modules
    #############################################################
    class data_dir:
        _subdir= "data"#(ref:src-dd-dflt)
        #############################################################
        ## @brief   Initilaization code
        #############################################################
        def __init__(self):#(ref:src-dd-init)
            self.reset()
        ##############################################################
        ## @brief   restores the default value of the number of traces
        ##############################################################
        def reset(self): #(ref:src-dd-reset)
            script_root = utl.get_script_root_path()
            data_path = os.path.join(script_root,self._subdir)
            self.path = data_path
        ##############################################################
        ## @brief   Ensures the new target string is a directory
        ##############################################################
        def validate(self, new_path):#(ref:src-dd-validation)
            return os.path.isdir(new_path)
        #############################################################
        ## @brief   Updates the target directory only if its a
        #           directory in the filesystem
        #############################################################
        def update(self,new_path):#(ref:src-dd-update)
            if self.validate(new_path):
                self.path = new_path
        #############################################################
        ## @brief   Print the parameter.
        #############################################################
        def print_param(self):#(ref:src-dd-print)
            print("Data Directory = %s" % self.path)
  #+END_SRC

***** DONE Numerical Parameters definition
  As previously stated most parameters are numerical, so a parent class is created to provide a common interface for them all and to ensure that all numerical parameters behave consistently.
  The numerical parameters are defined in [[src-config-num-param-class]], which provides the interfaces that define the numerical parameters
  - Initialization function :: The function defined in line [[(src-np-init)]], provide the initialization code for a generic numerical parameter, which is defined by the following parameters:
    - Default Value :: Is the value that the parameter takes by default, such as the voltage for the juncture.
    - Minimum value :: The minimum value acceptable for the parameter. With the maximum value defines the range of admissible values
    - Maximum value :: The maximum value acceptable for the parameter. With the minimum value defines the range of admissible values
    - Name :: The name defines a name for the parameter, which is useful to print information about it.
  - Reset function :: Defined in line  [[(src-np-reset)]], provides a mechanism to restore the parameter value to its default.
  - Validation function ::  Defined in line [[(src-np-validation)]] returns a boolean determining if the new value is within the range of accepted values
  - Update function :: Defined in line  [[(src-np-update)]] updates the parameter to a new value defined by the user, only if the value is within the accepted range, but if not it leaves the value unchanged
  - Update or default function :: Defined in line  [[(src-np-update-dflt)]] similar to the update function, this will reset the value to the default if the provided value is invalid; Also provides and optional error message in such case.
  - Print function ::  Defined in line  [[(src-np-print)]] provides an utility to print the current value to the terminal. Useful during testing and for sending messages
  - Error message :: Defined in line  [[(src-np-print)]] Will print and error message if the user tries to set the value of the parameter to an invalid quantity. This error function is intended for use through the configuration file, and is not necessary if the user uses the GUI.


  #+CAPTION: Numerical parameters class definition
  #+NAME: src-config-num-param-class
  #+BEGIN_SRC python  -n -r
    #############################################################
    ## @class   Numerical Parameter
    #  @brief   All functionality related to the numerical
    #           parameters
    #
    #  @details This class defines the basic behavior common to
    #           all numerical parameters, including common
    #           interfaces and values.
    #############################################################
    class numerical_parameter(object):
        #############################################################
        ## @brief   Initilaization code
        #############################################################
        def __init__(self,name,dflt_val,min_val,max_val):#(ref:src-np-init)
            self._dflt = dflt_val
            self._min = min_val
            self._max = max_val
            self.name = name
            self.reset()
        #############################################################
        ## @brief   restores the default value of the parameter
        #############################################################
        def reset(self): #(ref:src-np-reset)
            self.value = self._dflt
        #############################################################
        ## @brief   Determines if a new value is in the permited
        #           range
        #############################################################
        def validate(self, val):#(ref:src-np-validation)
            return (self._min <= val) & (val <= self._max)
        #############################################################
        ## @brief   Updates the stored value only if the new
        #           value is within range
        #############################################################
        def update(self,new_val):#(ref:src-np-update)
            if self.validate(new_val):
                self.value = new_val
        #############################################################
        ## @brief   Updates the stored value only if the new
        #           value is within range, otherwise returns to
        #           the default value
        #############################################################
        def update_or_dflt(self,new_val,verbose=False): #(ref:src-np-update-dflt)
            if self.validate(new_val):
                self.value = new_val
            else:
                self.reset()
                if verbose:
                    self.error_message(new_val)
        #############################################################
        ## @brief   Prints the parameter name and its value
        #############################################################
        def print_param(self):#(ref:src-np-print)
            print("{0} = {1}".format(self.name, self.value))
        #############################################################
        ## @brief   Prints error message if parameter outside range
        #############################################################
        def error_message(self,value):#(ref:src-np-error)
            print("------------------------------------------------")
            print("ERROR INVALID PARAMETER VALUE:")
            print("Value {0} is invalid for parameter {1}".format(self.name,value))
            print("Using default value {0}".format(self._dflt))
            print("Valid range for parameter {0} is:".format(self.name))
            print("Range min ={0}, Max ={1}".format(self._min, self._max))
            print("------------------------------------------------")
  #+END_SRC

  There is also a requirement to treat some numerical parameters as integers, therefore a specialization of the numerical parameters is shown in  [[src-config-int-param-class]], where some modifications and overloading are executed to provide with the desired properties.
  - Values must be integers :: This class must have all its values as integers, thus the default values and other parameters are cast as integers.
  - Validation Function :: Defined in line [[(src-ip-validation)]], this function also confirms that the parameter is an integer
  - Print as integer :: The printing function defined in line  [[(src-ip-print)]], changes the format to ensure that the parameter is displayed as an integer and not as a float. This is a minor change, but desirable for consistency.

  #+CAPTION: Integer parameters class definition
  #+NAME: src-config-int-param-class
  #+BEGIN_SRC python  -n -r
    #############################################################
    ## @class   Integer Parameter
    #  @brief   All functionality related to the numerical
    #           parameters that are to be treated as int
    #############################################################
    class integer_parameter(numerical_parameter):
        #############################################################
        ## @brief   Initilaization code
        #############################################################
        def __init__(self,name,dflt_val,min_val,max_val):
            _dflt = int(dflt_val)
            _min = int(min_val)
            _max = int(max_val)
            super(integer_parameter,self).__init__(name,_dflt,_min,_max)
        #############################################################
        ## @brief   Determines if a new int value is in the permited
        #           range, and integer
        #############################################################
        def validate(self, val): # (ref:src-ip-validation)
            is_valid = super(integer_parameter,self).validate(val)
            return  float(val).is_integer() & is_valid
        #############################################################
        ## @brief   Prints the parameter name and its value
        #############################################################
        def print_param(self): # (ref:src-ip-print)
            print("%s = %d" % (self.name, self.value))
  #+END_SRC

****** DONE Numerical Parameter Test                               :noexport:
  Test the functionality of a generic numerical parameter. Just excecuted by using =C-c C-c=. Should all be true
  #+BEGIN_SRC python :tangle no
    import modules.ui_config as c
    tp = c.numerical_parameter("Test", 7.8, 0.5,50)
    t1 = tp.value == 7.8
    t2 = tp.validate(-1.1) == False
    tp.update(0.12)
    t3 = tp.value == 7.8
    tp.update(9)
    t4 = tp.value == 9
    t5 = tp.validate(88) == False
    tp.update(55)
    t6 = tp.value == 9
    tp.update(0.7)
    t7 = tp.value == 0.7
    tp.reset()
    t8 = tp.value == 7.8
    t9 = tp.name == "Test"
    return [t1,t2,t3,t4,t5,t6,t7,t8,t9]
  #+END_SRC

  #+RESULTS:
  | True | True | True | True | True | True | True | True | True |

****** DONE Average points
   For each histogram measurement, at each voltage value, the instrument should take several consecutive measurements and average them, this parameter defined in [[src-config-avg-points-class]] is just a specialization of the integer parameter class shown in [[src-config-int-param-class]]

   #+CAPTION: Average points class definition
   #+name: src-config-avg-points-class
   #+BEGIN_SRC python -n -r
     #############################################################
     ## @class   avg_points
     #  @brief   All functionality related to the number of average points
     #
     #  @details This class defines the behavior of the jucture
     #           voltage. Provides the default values and range
     #           plus the corresponding interface.
     #############################################################
     class avg_points(integer_parameter):
         #############################################################
         ## @brief   Initilaization code
         #############################################################
         def __init__(self):
             _dflt = 32 # (ref:src-jv-dflt)
             _min = 1  #(ref:src-jv-min)
             _max = 99  #(ref:src-jv-max)
             _name = "Juncture Voltage"
             super(avg_points, self).__init__(_name,_dflt, _min, _max)
   #+END_SRC

****** DONE Juncture Voltage
       The juncture voltage defined in [[src-config-juncture-voltage-class]], as previously stated, is the parameter that controls the voltage applied to the juncture during the analysis. The juncture voltage class is just a specialization of the Numerical parameter class described in [[Numerical Parameters definition]]

   #+CAPTION: Juncture voltage class definition
   #+name: src-config-juncture-voltage-class
   #+BEGIN_SRC python  -n -r
     #############################################################
     ## @class   juncture_voltage
     #  @brief   All functionality related to the juncture voltage
     #
     #  @details This class defines the behavior of the jucture
     #           voltage. Provides the default values and range
     #           plus the corresponding interface.
     #############################################################
     class juncture_voltage(numerical_parameter):
         #############################################################
         ## @brief   Initilaization code
         #############################################################
         def __init__(self):
             _dflt = 0.1 # (ref:src-jv-dflt)
             _min = 0.0  #(ref:src-jv-min)
             _max = 0.3  #(ref:src-jv-max)
             _name = "Juncture Voltage"
             super(juncture_voltage, self).__init__(_name,_dflt, _min, _max)
   #+END_SRC

******* DONE juncture voltage test                                 :noexport:
   Test functionality. Just excecuted by using =C-c C-c=. Should all be true
   #+BEGIN_SRC python :tangle no
     import modules.ui_config as c
     jv = c.juncture_voltage()
     t1 = jv.value == 0.1
     t2 = jv.validate(1.1) == False
     jv.update(2)
     t3 = jv.value == 0.1
     jv.update(0.2)
     t4 = jv.value == 0.2
     t5 = jv.validate(-1.1) == False
     jv.update(5)
     t6 = jv.value == 0.2
     jv.update(0.22)
     t7 = jv.value == 0.22
     jv.reset()
     t8 = jv.value == 0.1
     t9 = jv.name == "Juncture Voltage"
     return [t1,t2,t3,t4,t5,t6,t7,t8,t9]
   #+END_SRC

    #+RESULTS:
****** DONE Piezo Speed Breaking
   The piezo speed breaking defined in [[src-config-piezo-brk-class]] is the parameter that controls the speed at which each measurement cycle is executed, defined in \([V/s]\). The Piezo speed class is just a specialization of the Numerical parameter class described in [[Numerical Parameters definition]].

   #+CAPTION: <<src-config-piezo-brk-class>> : Piezo speed breaking class definition
   #+name: src-config-piezo-brk-class
   #+BEGIN_SRC python -n -r
     #############################################################
     ## @class   piezo_break
     #  @brief   All functionality related to the
     #           piezo_speed_breaking
     #
     #  @details This class defines the behavior of the piezo
     #           speed voltage relations which is defined in [V/s]
     #           Provides the default values and range plus the
     #           corresponding interfaces.
     #############################################################
     class break_speed(numerical_parameter):
         #############################################################
         ## @brief   Initilaization code
         #############################################################
         def __init__(self):
             _dflt = 300.0 #(ref:src-ps-dflt)
             _min = 30.0   #(ref:src-ps-min)
             _max = 300.0  #(ref:src-ps-max)
             _name = "Piezo Speed"
             super(piezo_speed, self).__init__(_name,_dflt, _min, _max)
   #+END_SRC
******* DONE Piezo brk test                                        :noexport:
   Test functionality. Just executed by using =C-c C-c=. Should all be true
   #+BEGIN_SRC python :tangle no
     import modules.ui_config as c
     ps = c.break_speed()
     t1 = (ps.value == 300.0) & (ps.fixed_speed == 300.0)
     t2 = ps.validate(331.1) == False
     ps.update(334.2)
     t3 = (ps.value == 300.0) & (ps.fixed_speed == 300.0)
     ps.update(45.2)
     t4 = (ps.value == 45.2) & (ps.fixed_speed == 300.0)
     t5 = ps.validate(2.1) == False
     ps.update(700)
     t6 = (ps.value == 45.2) & (ps.fixed_speed == 300.0)
     ps.update(90)
     t7 = (ps.value == 90) & (ps.fixed_speed == 300.0)
     ps.reset()
     t8 = (ps.value == 300) & (ps.fixed_speed == 300.0)
     ps.update(-90)
     t9 = (ps.value == 300) & (ps.fixed_speed == 300.0)
     return [t1,t2,t3,t4,t5,t6,t7,t8,t9]
   #+END_SRC

   #+RESULTS:
   | True | True | True | True | True | True | True | True | True |
****** DONE Piezo Speed Making
   The piezo speed making defined in [[src-config-piezo-mk-class]] is the parameter that controls the speed at which each measurement cycle is executed, defined in \([V/s]\). The Piezo speed class is just a specialization of the Numerical parameter class described in [[Numerical Parameters definition]].

   #+CAPTION: <<src-config-piezo-mk-class>> : Piezo speed breaking class definition
   #+name: src-config-piezo-mk-class
   #+BEGIN_SRC python -n -r
     #############################################################
     ## @class   piezo_make
     #  @brief   All functionality related to the
     #           piezo_speed_making
     #
     #  @details This class defines the behavior of the piezo
     #           speed voltage relations which is defined in [V/s]
     #           Provides the default values and range plus the
     #           corresponding interfaces.
     #############################################################
     class piezo_make_speed(numerical_parameter):
         #############################################################
         ## @brief   Initilaization code
         #############################################################
         def __init__(self):
             _dflt = 500.0 #(ref:src-ps-dflt)
             _min = 30.0   #(ref:src-ps-min)
             _max = 500.0  #(ref:src-ps-max)
             _name = "Piezo Speed"
             super(piezo_speed, self).__init__(_name,_dflt, _min, _max)
   #+END_SRC
******* DONE Piezo make test                                       :noexport:
   Test functionality. Just executed by using =C-c C-c=. Should all be true
   #+BEGIN_SRC python :tangle no
     import modules.ui_config as c
     ps = c.make_speed()
     t1 = (ps.value == 300.0) & (ps.fixed_speed == 300.0)
     t2 = ps.validate(531.1) == False
     ps.update(334.2)
     t3 = (ps.value == 300.0) & (ps.fixed_speed == 300.0)
     ps.update(45.2)
     t4 = (ps.value == 45.2) & (ps.fixed_speed == 300.0)
     t5 = ps.validate(2.1) == False
     ps.update(700)
     t6 = (ps.value == 45.2) & (ps.fixed_speed == 300.0)
     ps.update(90)
     t7 = (ps.value == 90) & (ps.fixed_speed == 300.0)
     ps.reset()
     t8 = (ps.value == 300) & (ps.fixed_speed == 300.0)
     ps.update(-90)
     t9 = (ps.value == 300) & (ps.fixed_speed == 300.0)
     return [t1,t2,t3,t4,t5,t6,t7,t8,t9]
   #+END_SRC

   #+RESULTS:
   | True | True | True | True | True | True | True | True | True |
****** DONE Number of traces
   The number of traces defined in [[src-config-traces-class]] is the parameter that controls the number of measurement cycles excecuted using the piezoelectric actuator, where a trace is a full cycle going from closed to open and back. The traces class is a simple specialization of the Integer parameter class described in [[Numerical Parameters definition]] ([[src-config-int-param-class]]).

   #+CAPTION: Number of traces class definition
   #+NAME: src-config-traces-class
   #+BEGIN_SRC python -n -r
     #############################################################
     ## @class   traces
     #  @brief   All functionality related to the number of traces
     #
     #  @details This class defines the parameter that controls
     #           the number of traces (runs) performed using the
     #           piezo. Each trace correspond to a full cycle
     #           from closed juncture to open and back.
     #############################################################
     class traces(integer_parameter):
           #############################################################
           ## @brief   Initilaization code
           #############################################################
           def __init__(self):
               _dflt = int(5000)  #(ref:src-tr-dflt)
               _min = int(1)      #(ref:src-tr-min)
               _max = int(20000)  #(ref:src-tr-max)
               _name = "Number of Traces"
               super1(traces, self).__init__(_name,_dflt, _min, _max)
   #+END_SRC
******* DONE number traces test                                    :noexport:
   #+BEGIN_SRC python :tangle no
     import modules.ui_config as c
     tr = c.traces()
     t1 = tr.value == 5000
     t2 = tr.validate(40000) == False
     tr.update(5.2)
     t3 = tr.value == 5000
     tr.update(200)
     t4 = tr.value == 200
     t5 = tr.validate(-100) == False
     tr.update(120000)
     t6 = tr.value == 200
     tr.update(8000)
     t7 = tr.value == 8000
     tr.reset()
     t8 = tr.value == 5000
     return [t1,t2,t3,t4,t5,t6,t7,t8]
   #+END_SRC

   #+RESULTS:
   | True | True | True | True | True | True | True | True |
****** DONE Display xmin
   To display the measurements on real time, we show the histogram, and we define the minimum value for the *X-axis*, since we plot in *distance* value, we define the minimun as:

   #+CAPTION: display xmin class definition
   #+name: src-config-xmin-class
   #+BEGIN_SRC python  -n -r
     #############################################################
     ## @class   display_xmin
     #  @brief   All functionality related to the minimum of X axis
     #
     #  @details This class defines the behavior of the minimum
     #           for the X axis. Provides the default values and range
     #           plus the corresponding interface.
     #############################################################
     class display_xmin(numerical_parameter):
         #############################################################
         ## @brief   Initilaization code
         #############################################################
         def __init__(self):
             _dflt = -0.5 # (ref:src-jv-dflt)
             _min = -0.9  #(ref:src-jv-min)
             _max = -0.1  #(ref:src-jv-max)
             _name = "display_xmin"
             super(display_xmin, self).__init__(_name,_dflt, _min, _max)
   #+END_SRC
****** DONE Display xmax
   To display the measurements on real time, we show the histogram, and we define the maximum value for the *X-axis*, since we plot in *distance* value, we define the minimun as:

   #+CAPTION: Display xmax class definition
   #+name: src-config-xmax-class
   #+BEGIN_SRC python  -n -r
     #############################################################
     ## @class   display_xmax
     #  @brief   All functionality related to the maximum of X axis
     #
     #  @details This class defines the behavior of the maximum
     #           for the X axis. Provides the default values and range
     #           plus the corresponding interface.
     #############################################################
     class display_xmax(numerical_parameter):
         #############################################################
         ## @brief   Initilaization code
         #############################################################
         def __init__(self):
             _dflt = 2 # (ref:src-jv-dflt)
             _min = 0.9  #(ref:src-jv-min)
             _max = 3.9  #(ref:src-jv-max)
             _name = "display_xmax"
             super(display_xmax, self).__init__(_name,_dflt, _min, _max)
   #+END_SRC
****** DONE Display Gmin
   To display the measurements on real time, we show the histogram, and we define the minimum value for the *Y-axis*, since we plot in *conductance* value, we define the minimun as:

   #+CAPTION: Display Gmin class definition
   #+name: src-config-gmin-class
   #+BEGIN_SRC python  -n -r
     #############################################################
     ## @class   display_Gmin
     #  @brief   All functionality related to the minimum of Y axis
     #
     #  @details This class defines the behavior of the minimum
     #           for the Y axis. Provides the default values and range
     #           plus the corresponding interface.
     #############################################################
     class display_Gmin(numerical_parameter):
         #############################################################
         ## @brief   Initilaization code
         #############################################################
         def __init__(self):
             _dflt = 1e-7 # (ref:src-jv-dflt)
             _min = 1e-9  #(ref:src-jv-min)
             _max = 1e-6  #(ref:src-jv-max)
             _name = "display_Gmin"
             super(display_Gmin, self).__init__(_name,_dflt, _min, _max)
   #+END_SRC
****** DONE Display Gmax
   To display the measurements on real time, we show the histogram, and we define the maximum value for the *Y-axis*, since we plot in *Conductance* value, we define the maximum as:

   #+CAPTION: Display Gmax class definition
   #+name: src-config-gmax-class
   #+BEGIN_SRC python  -n -r
     #############################################################
     ## @class   display_xmax
     #  @brief   All functionality related to the maximum of Y axis
     #
     #  @details This class defines the behavior of the maximum
     #           for the X axis. Provides the default values and range
     #           plus the corresponding interface.
     #############################################################
     class display_xmax(numerical_parameter):
         #############################################################
         ## @brief   Initilaization code
         #############################################################
         def __init__(self):
             _dflt = 10 # (ref:src-jv-dflt)
             _min = 1  #(ref:src-jv-min)
             _max = 100  #(ref:src-jv-max)
             _name = "display_Gmax"
             super(display_Gmax, self).__init__(_name,_dflt, _min, _max)
   #+END_SRC

****** DONE Display num-D-slots
   To display the measurements on real time, we show the histogram, and we define the number of partitions or ranges for the values in the *X-axis* since we plot in *distance* value, we the number of partitions as:

   #+CAPTION: Display num-D-slots class definition
   #+name: src-config-nDbin-class
   #+BEGIN_SRC python  -n -r
     #############################################################
     ## @class   display_nDbins
     #  @brief   All functionality related to the X axis slots(bins)
     #
     #  @details This class defines the behavior of the number of
     #           slots for the X axis. Provides the default value
     #           and range plus the corresponding interface.
     #############################################################
     class display_nXbins(integer_parameter):
         #############################################################
         ## @brief   Initilaization code
         #############################################################
         def __init__(self):
             _dflt = 161 # (ref:src-jv-dflt)
             _min = 99  #(ref:src-jv-min)
             _max = 999  #(ref:src-jv-max)
             _name = "display_nDbins"
             super(display_nDbins, self).__init__(_name,_dflt, _min, _max)
   #+END_SRC

****** DONE Display num-G-slots
   To display the measurements on real time, we show the histogram, and we define the number of partitions or ranges for the values in the *Y-axis* since we plot in *conductance* value, we the number of partitions as:

   #+CAPTION: Display num-G-slots class definition
   #+name: src-config-nGbins-class
   #+BEGIN_SRC python  -n -r
     #############################################################
     ## @class   display_nGbins
     #  @brief   All functionality related to the Y axis slots(bins)
     #
     #  @details This class defines the behavior of the number of
     #           slotsfor the Y axis. Provides the default value
     #           and range plus the corresponding interface.
     #############################################################
     class display_nGbins(integer_parameter):
         #############################################################
         ## @brief   Initilaization code
         #############################################################
         def __init__(self):
             _dflt = 251 # (ref:src-jv-dflt)
             _min = 99  #(ref:src-jv-min)
             _max = 999  #(ref:src-jv-max)
             _name = "display_nGbins"
             super(display_nGbins, self).__init__(_name,_dflt, _min, _max)
   #+END_SRC






   , thus the UI module can be thought as the result of 3 pieces.
   - Program Interface :: The UI - program interface is how the UI interacts with the rest of the program. See [[UI-Program Interface]]
   - GUI :: The graphical User interface is how the program interacts with the user. See [[UI-GUI]]
   - Configuration Files :: Full textual interfaces so users can set a configuration file which takes cares of all modifiable constants of the problem, without needing to use a GUI
**** TODO Non-Configurable parameters definitions
There are parameters that con modify the behavior of the run, but are not expected to be modified by the user, therefore are hardcoded in the program. The code fragment [[src-parameters-global-constants]] shows the constant definitions which are:
- G0 :: Conductance of a "1-gold-atom" channel
- Start Juncture voltage :: The voltage of the juncture before starting the measurement. The juncture voltage is modified in order to measure
- End Juncture voltage :: The voltage of the juncture after the end of the measurement. The juncture voltage moved back to a rest value
#+caption Global constants
#+name: src-parameters-global-constants
#+BEGIN_SRC python
  # Non configurable parameters
  class GLOBAL_CONTANTS:
      G0 = 7.74809173e-5          # Quantum Conductance
      start_jv = 0
      end_jv = 0
      IV_settling_time = 10       # ms
      IV_max_data_points = 5000   # seg
#+END_SRC

***** TODO Logaritmic amplifier calibration
  #+CAPTION: log amplifier
  #+BEGIN_SRC python
    class adwin_log_aplifier:
        def __init__(self):
            calibration_dir = ADW_GCONST.PROGRAM_DIR
            root_path = utl.get_script_root_path()
            program_path = os.path.join(root_path,self._adwin_subdir)
            filename = "calibrationIO.txt"
            calibration_file = os.path.join(program_path,filename)
            if (os.path.isfile(calibration_file)):
                read_data_file(calibration_file)
            else:
                raise Exception("Bad file, check %s" %calibration_file)
        def read_data_file(self, filename):
            # reads matrix from data file. As optional input a column can be specified
            data=[]
            file =open(filename)
            for line in file:
                line_list = [float(x) for x in line.split()]
            data.append(line_list)
            self.data = data
        def get_calibration(self):
            return self.data
  #+END_SRC

*** TODO UI-Program Interface                                 :Heavyrefactor:
    :PROPERTIES:
    :header-args+: :tangle   modules/ui_config.py
    :header-args+: :noweb    tangle
    :END:
   # As with any module there is a section for the imports and the file headers, but these are unninteresting for any reader, thus they are put in comments and not exported to a PDF/HTML result
#+BEGIN_SRC python :exports none
  #################################################################
  ## @file    ui_config.py
  #  @author  Joaquin Figueroa
  #  @date    Fri Aug 12 2016
  #  @brief   Provides the definitions and parameters for the UI
  #
  #  @details This file provides a all the necessary helper
  #           functions to interface the different parameters
  #           with the program.
  #################################################################
  from PyQt4 import QtGui
  from PyQt4 import QtCore
  from modules.ui_gui import run_gui
  import modules.utilities as utl
  import os
  import sys
  <<ui-basic-params-defaults>>
  <<ui-advanced-params-defaults>>
  <<ui-presentation-params-defaults>>
#+END_SRC

Therefore the output of the UI execution is a class of 2 values with one value being the command to be executed, and the other the configuration for the measurements, which has a default initialization, but also provides functions to replace the original values with new ones
 #+BEGIN_SRC python
   ############################################################
   ## @class   UI_CONFIG
   #  @details This class has the return type of the UI class
   #           The return type has:
   #           1- Command to be executed (exit, measure)
   #           2- Configuration for the measurements
   ############################################################
   class UI_CONFIG:
       def __init__(self):
           self.cmd    = UI_CMD.EXIT
           self.config = UI_CONFIG_PARAMS()

       ############################################################
       ## @brief   Updates the ui_cmd with a new one
       ############################################################
       def update_cmd(self, new_cmd):
           self.cmd = new_cmd

       ############################################################
       ## @brief   Updates the config with a new one
       ############################################################
       def update_config(self, new_config):
           self.config = new_config
 #+END_SRC

**** DONE UI command
 Now the command to be executed has only a few possible values, which are used to, as previously explained, to terminate the program, or execute one of the routines.
 #+BEGIN_SRC python
   ############################################################
   ## @class  CMD
   #  @brief  UI calss to encode the possible commands for the
   #         program
   ############################################################
   class UI_CMD:
       EXIT    = 0
       M_BREAK = 1
       MEASURE = 2
 #+END_SRC

**** TODO Configuration-structure
Test configuration structure, I meed need to refactor this.
#+BEGIN_SRC python
  class iv_config:
      log_array = 0
      start_jv= 0
      measure_jv= 0
      end_jv= 0
      wait= 0
      avg= 0
      max_data= 0
      g0= 0

  class histo_config:
      log_array = 0
      start_jv= 0
      measure_jv= 0
      end_jv= 0
      break_wait= 0
      make_wait= 0
      avg= 0
      i_brk = 0
      i_mk = 0
      start_piezo_v = 0
      g0= 0

  class display_config:
      number_traces = 5000
      nGbins = 251
      nDbins = 161
      xmin = -0.5                 # nm
      xmax = 2                    # nm
      Gmin = 1e-7                 # G0
      Gmax = 10                   # G0
#+END_SRC
**** TODO UI Configuration Parameters
The UI configuration is a list of variables which are used through the measurements for configuring the experiments or for controlling the presentation of the results, for simplicity the variables are classified in groups
- Basic parameters :: These are the parameters that control the run and define it see [[UI-Basic parameters ]]
- Advanced parameters :: There are more advanced parameters that influence the run, but have minor impact (usually) when compared with the other parameters, and the user is rarely ever expected to modify them. See [[UI-Advanced parameters]]
- Presentation parameters :: The results of the experiment is processed in graph; some of the parameters for the graph can be tweaked to improve the readability of them. See [[UI-Presentation]]

#+BEGIN_SRC python
  ############################################################
  ## @class   UI_CONFIG
  #  @details This class stores all configuration values to be
  #           used for the measurements.
  ############################################################
  class UI_CONFIG_PARAMS:
      def __init__(self):
          self._b_params = basic_params()
          self._a_params = adv_params()
          self._p_params = presentation()

      <<ui-config-bp-interface>>
      <<ui-config-ap-interface>>
      <<ui-config-pp-interface>>
#+END_SRC

Finally the interface with the rest of the program is defined through a single method

#+BEGIN_SRC python
  def ui_get_gui_config():
      retval = run_gui()
      return retval
#+END_SRC

Before describing each parameter group, is clear that most parameters are numerical, therefore it makes sense to define a class which encapsulates the common functionality for the numerical parameters. This class is defined in [[Numerical Parameters definition]]

**** TODO UI-Advanced parameters
#+BEGIN_SRC python
  class adv_params:
        def __init__(self):
              self.asdf = 1
#+END_SRC

#+NAME: ui-config-ap-interface
#+BEGIN_SRC python

#+END_SRC

#+name: ui-advanced-params-defaults
#+BEGIN_SRC python :exports none
piezo_start_V = 0.0         # V
high_G = 30.0              # G0
inter_G = 20.0              # G0
low_G = 10.0              # G0
piezo_speed_breaking1 = 300.0        # V/s
piezo_speed_breaking2 = 300.0        # V/s (30 to 300) Este es el que se puede cambiar
piezo_speed_making = 500.0        # V/s
#post_breaking_voltage = 230.0       #
post_breaking_voltage = 300.0       # cambia cuanto abro despues de que rompo
nGbins = 251
nDbins = 161
xmin = -0.5 # nm
xmax = 2    # nm
Gmin = 1e-7 # G0
Gmax = 10   # G0
#+END_SRC

**** TODO UI-Presentation
#+name: ui-presentation-params-defaults
#+BEGIN_SRC python :exports none
todoJUNCTURE_VOLTAGE_DFLT = 0  #[V]
todoPIEZO_SPEED_DFLT = 0       #[V/S]
todoDATA_DIRECTORY_DFLT = "./Data"
#+END_SRC

#+BEGIN_SRC python
  class presentation:
        def __init__(self):
              self.asdf = 1
#+END_SRC

#+NAME: ui-config-pp-interface
#+BEGIN_SRC python

#+END_SRC
**** TODO UI-Basic parameters
The basic parameters used to configure the measurement are parameters that are the most likely to be modified by the used, and whose side effects are better understood. These parameters usually deal with the speed and number of data points.
In a more traditional object oriented paradigm, each parameter is controlled by its own class, which defines their default values, range, validation functions and how each parameter is updated.

The basic parameters are:
- Juncture Voltage :: This represents the voltage applied to the junture. See [[Juncture Voltage]]
- Piezo Speed Breaking :: This parameters defines the voltage rate which is applied to the piezoelectric, which has a direct impact on the juncture. See [[Piezo Speed Breaking]]
- Number of traces :: Traces are each process of opening and closing the juncture using the piezoelectric device. Each trace is a full cycle, and the number of traces represent the number of measurements to be taken. See [[Number of traces]]
- Data directory :: The results of the experiment are stored in a specific directory. See [[Data directory]]


#+BEGIN_SRC python
  class basic_params:
        def __init__(self):
              self.juncture = juncture_voltage()
              self.piezo_speed = piezo_speed()
              self.traces = traces()
              self.data_dir = data_dir()
        def restore_defaults(self):
              self.juncture.reset()
              self.piezo_speed.reset()
              self.traces.reset()
              self.data_dir.reset()
        def print_all(self):
              print("--- Basic Parameters ---")
              self.juncture.print_param()
              self.piezo_speed.print_param()
              self.traces.print_param()
              self.data_dir.print_param()
#+END_SRC

*** TODO UI-GUI
    :PROPERTIES:
    :header-args+: :tangle   modules/ui_gui.py
    :header-args+: :noweb    tangle
    :END:
# As with any module there is a section for the imports and the file headers, but these are unninteresting for any reader, thus they are put in comments and not exported to a PDF/HTML result
#+BEGIN_SRC python :exports none
  #################################################################
  ## @file    ui_gui.py
  #  @author  Joaquin Figueroa
  #  @date    Fri Aug 12 2016
  #  @brief   Provides the GUI for configuring the experiment
  #
  #  @details This file provides a GUI for the user to be able to
  #           configure the experiment and run it.
  #################################################################
  from PyQt4 import QtGui
  from PyQt4 import QtCore
  import ui_config as conf
  import sys
  <<ui-basic-params-defaults>>
  <<ui-advanced-params-defaults>>
  <<ui-presentation-params-defaults>>
#+END_SRC

The Graphical user interface consist of a window that allows the user to tweak with each of the parameters defined in [[UI-Program Interface]], plus buttons for deciding which action to take.

This program uses [[https://wiki.python.org/moin/PyQt][PyQt4]] as a GUI framework. To run a GUI, first is necessary to create an "application", then instantiate a widget, which corresponds to the specific UI that is being implemented to finally "execute" the "application". For a reference on how this is done under PyQt a tutorial can be found on [[http://zetcode.com/gui/pyqt4/]].

#+BEGIN_SRC python
  ############################################################
  ## @brief   Runs the GUI for the program
  ############################################################
  def run_gui():
      app = QtGui.QApplication(sys.argv) # Create "aplication"
      config_window = ui_config_window() # Instantiate widget
      app.exec_()                        # Execute appliaction
      return config_window.ui_config
#+END_SRC

**** TODO Configuration Window

The configuration window, shown in [[gui-config-window]] is a python widget which represents the user interface of the program. As usual with user interfaces they require an large amount of code only to initialize it where is difficult to separate the functionality.

The standard procedure in python to build a widget is to delegate the initialization code to the parent class, and the UI elements specific to it, such as the buttons are defined in an internal initialization function of the class, commonly named =initUI= in line [[(fn-initUI)]]

The window object is composed of 3 basic elements:
- Config :: The contents of the window used to store and pass the configuration to the rest of the program shown in line [[(ui-config)]]
- Buttons ::  The UI has a button for each action including the measurements strategies to be used and to exit the program shown in line [[(ui-buttons)]]. For details see [[Buttons Layout]]
- Configuration :: The forms used to configure the parameters of the run defined in line [[(ui-config)]]. For details see [[Configuration Parameters Layout]]

Obviously as an object it also provides functionality to interact with it, mainly through the buttons of it, the idea is that only the window can modify it as to keep the interface as clean as possible.

The widget provides a callback defined in line [[(ui-close-cb)]] to be used by the buttons which will close the widget and ensure that the selected command, for example to measure, is executed
#+CAPTION: Definition of the configuration window
#+NAME: gui-config-window
#+BEGIN_SRC python -n -r
  ############################################################
  ## @class   ui_config_window
  #  @brief   Provides The UI window for the program
  #
  #  @details This Object provides the user interface to
  #           configure the measurements and which procedures
  #           to take.
  #           The object has the description of the window
  #           composed by the text dialogs and the buttons
  #           to run the simulation, which are stored as
  #           part of the window. The object also provides
  #           the functions to interface it.
  #           - initUI: Initialize the window
  ############################################################
  class ui_config_window(QtGui.QWidget):
      # Default constructor
      def __init__(self):
          super(ui_config_window, self).__init__()
          self.initUI()

      ############################################################
      ## @brief   Initializes the window
      #  @details Initialized the window components, which are the
      #           configs, the buttons and the configuration.
      #           Also ensures the layout of the UI elements
      ############################################################
      def initUI(self):    #(ref:fn-initUI)
          self.ui_config = conf.UI_CONFIG() #(ref:ui-config)

          buttons_layout = ui_create_buttons_layout(self) #(ref:ui-buttons)
          config_layout  = ui_create_config_layout(self)  #(ref:ui-config)
          vbox = QtGui.QVBoxLayout()
          vbox.addStretch(1)
          vbox.addLayout(config_layout)
          vbox.addLayout(buttons_layout)

          self.setLayout(vbox)
          self.setGeometry(300, 300, 300, 150)
          self.setWindowTitle('Buttons')
          self.show()

      ############################################################
      ## @brief   Interface to close the window and excecute a
      #           command
      ############################################################
      def close_with_cmd(self, cmd): #(ref:ui-close-cb)
          self.ui_config.update_cmd(cmd)
          QtCore.QCoreApplication.instance().quit()
#+END_SRC
**** TODO Buttons Layout
The buttons provide the functionality to launch the different process of the tool. Therefore clicking a button will close the UI and excecute the action stated on it. Also a small tooltip is provided in case the user requires additional information.

To define a button, first it must be created using the text to be displayed, then the attributes associated to it, meaning the action it will perform and the tooltip displayed, if any.
A special mention is made for the callback used in each button as it uses anonymous functions as shown in line [[(lambda-btn)]] to call the function that excecutes the corresponding action. While a more advanced programming technique (see [[https://en.wikipedia.org/wiki/Anonymous_function]]) it provides the cleanest and easiest method to provide this functionality (See also [[http://stackoverflow.com/questions/15080731/call-a-function-when-a-button-is-pressed-pyqt]])

Finally the buttons created are added to the layout of the button section of the window which is returned to the user.
#+BEGIN_SRC python -r -n
  ############################################################
  ## @brief   Creates buttons layout and returns it
  #
  #  @details The function creates a layout to place the
  #           buttons to perform the different actions of the
  #           program.
  #           The layout creates the following buttons:
  #           - Quit Button: Ends the program
  #           - Break Button: Use the motor do break junction
  #           - Measure Button: Do a break junction and then
  #                             use the piezo to measure
  ############################################################
  def ui_create_buttons_layout(widget):
      # Quit Button
      quit_button = QtGui.QPushButton("Quit")
      quit_button.clicked.connect(
          lambda: widget.close_with_cmd(conf.UI_CMD.EXIT)) (ref:lambda-btn)
      quit_button.setToolTip("Terminates the program")
      # Break Button
      break_button = QtGui.QPushButton("Only break")
      break_button.clicked.connect(
          lambda: widget.close_with_cmd(conf.UI_CMD.M_BREAK))
      break_button.setToolTip("Use the motor to create a break junction.")
      # Measure Button
      measure_button = QtGui.QPushButton("Full Measure")
      measure_button.clicked.connect(
          lambda: widget.close_with_cmd(conf.UI_CMD.MEASURE))
      measure_button.setToolTip(
          "Performs measurement using the motor and piezo")

      # Build Layout
      hbox = QtGui.QHBoxLayout()
      hbox.addStretch(1)
      hbox.addWidget(quit_button)
      hbox.addWidget(break_button)
      hbox.addWidget(measure_button)

      vbox = QtGui.QVBoxLayout()
      vbox.addStretch(1)
      vbox.addLayout(hbox)
      return vbox
#+END_SRC

**** TODO Configuration Parameters Layout
Since the configuration parameters are split in different groups so it is the layout of the configuration window, leaving a vertical section of the window to each group. The top level of the configuration parameters layout is shown in [[config-param-layout]], using the same techniques already used for the buttons. The rest of the description of the configuration parameters GUI is described in different sections:

- Basic parameters :: The layout for the basic parameters is described in [[Basic parameters layout]]
- Advanced parameters :: The layout for the advanced parameters is described in [[Advanced parameters layout]]
- Presentation parameters :: The layout for the presentation parameters is described in [[Presentation parameters layout]]
- Utilities :: Some utilities shared by all the different layouts are described in [[Configuration parameters layout utilities]]

#+CAPTION: Configuration parameters layout
#+NAME: config-param-layout
#+BEGIN_SRC python
  ############################################################
  ## @brief   Describes the configuration parameters layout
  #
  #  @details This function provides the layout for the portion
  #           of the window that allows the user to configure
  #           the parameters for the run.
  #           The layout is split in 3 vertical sections one
  #           with each parameter group.
  #           Each group is preceded by a small label
  #           identifying the group
  ############################################################
  def ui_create_config_layout(ui_config_window):
      # Define each group layout
      basic_param_layout = ui_basic_param_layout(ui_config_window)
      adv_param_layout = ui_adv_param_layout(ui_config_window)
      presentation_param_layout = ui_presentation_param_layout(ui_config_window)
      # Define the labels
      basic_label = QtGui.QLabel("---- Basic Parameters ----")
      adv_label = QtGui.QLabel("---- Advanced Parameters ----")
      presentation_label = QtGui.QLabel("---- Presentation Parameters ----")
      # Configure the layout
      vbox = QtGui.QVBoxLayout()
      vbox.addStretch(1)
      vbox.addWidget(basic_label)
      vbox.addLayout(basic_param_layout)
      vbox.addWidget(adv_label)
      vbox.addLayout(adv_param_layout)
      vbox.addWidget(presentation_label)
      vbox.addLayout(presentation_param_layout)
      return vbox
#+END_SRC

***** TODO Basic parameters layout
#+BEGIN_SRC python
  def ui_basic_param_layout(window):
      basic_params = window.ui_config.config._b_params ## Fix this
      # Num parameters fields
      jv_label, jv_text = num_param_label_textbox(basic_params.juncture)
      ps_label, ps_text = num_param_label_textbox(basic_params.piezo_speed)
      tr_label, tr_text = num_param_label_textbox(basic_params.traces)
      # Change directory dialog and fields
      dir_label = QtGui.QLabel(basic_params.data_dir.path)
      dir_btn = QtGui.QPushButton('Change Directory')
      dir_btn.clicked.connect(lambda: showDialog(window,dir_label))
      # Add fields to the layout
      grid = QtGui.QGridLayout()
      grid.setSpacing(10)

      grid.addWidget(jv_label,1,0)
      grid.addWidget(jv_text,1,1)

      grid.addWidget(ps_label,2,0)
      grid.addWidget(ps_text,2,1)

      grid.addWidget(tr_label,3,0)
      grid.addWidget(tr_text,3,1)

      grid.addWidget(dir_label,4,0)
      grid.addWidget(dir_btn,4,1)

      return grid
#+END_SRC

***** TODO Advanced parameters layout

***** TODO Presentation parameters layout
#+BEGIN_SRC python

  def ui_adv_param_layout(window):
      return ui_basic_param_layout(window)

  def ui_presentation_param_layout(window):
      return ui_basic_param_layout(window)

#+END_SRC

***** TODO Configuration parameters layout utilities
As previously stated, some of the functionalities that are required to describe a configuration parameter layout are too complex to be described clearly within each parameter layout, and these are common, so in order to keep the code and the structure as simple as possible, these functionalities are described separately. The utilities are:
- Parameter validator :: Most parameters are numerical, and the functionality described in [[Numerical parameter validator]], ensures that the user does not enter invalid values
- Parameter label creator :: Parameters that are entered through a text-box, have the same functionality, which only depends on the parameter at hand. The functionality described in  [[Parameter labels]] creates the labels based only on the parameter
- Change directory dialog :: A simple functionality to show the change directory dialog to the user is described in [[Change directory dialog]]

****** DONE Numerical parameter validator
The GUI is described using PyQt, which provides a mechanism to ensure that no invalid values are written or stored in the different txet-boxes. This mechanism is provided through the definition of a specialization of the [[http://doc.qt.io/qt-4.8/qvalidator.html][QValidator Class]], as shown in [[src-qvalidator-num-param]].

The overloading is performed by adding a parameter to the validator in the initialization function shown in line [[(src-qvalidator-np-init)]]. Then the =validate= function is overloaded by leveraging the =validate= function of the parameter as shown in the line [[(src-qvalidator-np-val)]], and allowing only values that are valid for the parameter.

#+CAPTION: QValidator specialization for numerical parameters
#+NAME: src-qvalidator-num-param
#+BEGIN_SRC python -n -r
  #############################################################
  ## @class   QValidator_num_param
  #  @brief   Validator for numerical parameters
  #
  #  @details This class provides a specialization of the
  #           QValidator class for numerical parameters and
  #           allow only values that are valid for the
  #           parameter.
  #############################################################
  class QValidator_num_param(QtGui.QValidator):
          #############################################################
          ## @brief   Initialization function, with the parameter
          #############################################################
          def __init__(self, param): #(ref:src-qvalidator-np-init)
              QtGui.QValidator.__init__(self)
              self.param = param
          #############################################################
          ## @brief   Validate function using the parameter validation
          #           Ensures data is a number.
          #############################################################
          def validate(self, text, pos):#(ref:src-qvalidator-np-val)
                  try:
                          num = float(text)
                  except ValueError:
                          return (QtGui.QValidator.Invalid, pos)

                  if self.param.validate(num):
                          self.param.update(num)
                          return (QtGui.QValidator.Acceptable, pos)
                  return (QtGui.QValidator.Invalid, pos)
#+END_SRC

****** TODO Parameter labels
To provide the GUI for a parameter, a label and a text-box are needed, however for numerical parameters, the only difference between a set is the parameter, therefore a function is created that create both based only on a specific parameter.

#+BEGIN_SRC python
  #############################################################
  ## @brief   Creates a label and textbox for a numerical
  #           parameter.
  #############################################################
  def num_param_label_textbox(parameter):
      label = QtGui.QLabel(parameter.name)
      textbox = QtGui.QLineEdit()
      param_validator = QValidator_num_param(parameter)
      textbox.setValidator(param_validator)
      textbox.setText(str(parameter.value))
      return (label, textbox)
#+END_SRC

****** Change directory dialog
#+BEGIN_SRC python
  def showDialog(window,dir_label):
      data_dir = window.ui_config.config._b_params.data_dir
      fname = QtGui.QFileDialog.getExistingDirectory(window, 'Open file',
              data_dir.path)
      if(fname):
          data_dir.update(fname)
          dir_label.setText(data_dir.path)
          print(data_dir.path)
#+END_SRC

** TODO Motor break junction
   :PROPERTIES:
   :header-args+:  :tangle   modules/motor_break.py
   :END:
#+BEGIN_SRC python
  def motor_break_juncture():
      print ("Picked Motor break")

#+END_SRC

** TODO Measurement with Piezo
   :PROPERTIES:
   :header-args+:  :tangle   modules/piezo_measure.py
   :END:

#+BEGIN_SRC python
  def measure_sample():
      print("Picked measure sample")

#+END_SRC

** TODO General purpose Utilities
   :PROPERTIES:
   :header-args+:  :tangle   modules/utilities.py
   :header-args+:  :noweb    tangle
   :END:
As with many programs, there are some general purpose functionalities that do not fit cleanly in other sections or files. This section is for these types of utilities.
#+BEGIN_SRC python :exports none
  #################################################################
  ## @file    utilities.py
  #  @author  Joaquin Figueroa
  #  @brief   General purpose utilities
  #
  #  @details This file stores several general purpose utilities
  #           that do not fit cleanly anywhere else. Obviously
  #           grat care has been tanke to ensure that this file
  #           is kept small
  #################################################################
  import os
  import inspect
#+END_SRC
*** Path utilities.
Although Python already provides with a good interface to interface with the filesystem, without going into the specifics, there is still a need to provide some specific functionality for the program considering the usage of several files in the filesystem relative to the script root, thus to provide with the appropriate interface, this archive provides:
- Determine script root :: This program uses several files in paths relative to the script root, therefore is necessary to provide a functionality to determine the script root.
#+BEGIN_SRC python
  #############################################################
  ## @brief   Returns the path to the main.py directory
  #  @details Uses the inspect functionality to determine
  #           the current filename, then determines the
  #           absolute path. Since this file is at a fixed
  #           path from the script_root, it's returned
  #############################################################
  def get_script_root_path():
      fname = inspect.getframeinfo(inspect.currentframe()).filename
      module_path = os.path.dirname(os.path.abspath(fname))
      script_root_path = os.path.dirname(module_path)
      return script_root_path
#+END_SRC


* TODO Adwin Driver
  :PROPERTIES:
  :header-args+: :tangle modules/adwin_driver.py
  :header-args+: :noweb yes
  :header-args+: :comments noweb
  :END:
The adwin driver is mostly a convenience layer between the ADwin and the Python program which uses it. This program will provide a different layer for each different process related to the different measurements. For convenience each process is isolated in its own class. Using a class inheritance scheme this file is split in different sections

- Header :: As with many files a necessity. See [[Adwin driver-header]]
- Base Class :: Shown in  [[Adwin driver-base class]], Provides the minimum interface over which to build the different drivers
- IV Measurement :: Shown in [[Adwin IV-measurement class]] Provides the interface for the continuous  measurement.
- Histogram measurment :: Shown in [[Adwin histogram-measurement class]], Provides the interfaces for generating histogram data for a full break-restore cycle.
- Utility functions :: Functionality directly tied to the ADwin, but which is not part of the interface with the instrument. See  [[Adwin driver-utilities]]

** DONE Adwin driver-header
#+BEGIN_SRC python
  #################################################################
  ## @file    adwin_driver.py
  #  @author  Joaquin Figueroa
  #  @date    Fri Nov 4, 2016
  #  @brief   Provides the interfaces for the Adwin
  #
  #  @details This file provides  the Adwin interface,
  #           which defines high and low level functionalities.
  #           The user should use onlythe high level functionality
  #           if possible.
  #################################################################
  import ADwin
  import os
  import numpy as np
  import modules.utilities as utl
#+END_SRC
** TODO Adwin driver-base class
The Adwin base class, provides with the minimum data structure and global parameters in order to define a proper driver for ADwin measurement process. This part of the file is split in:
- Constants :: Shown in [[Adwin driver-global constants]] defines the global constants, which represents parameters that  are needed for any process related to the ADwin
- Interface :: Shown in [[Adwin driver-base class Interface]], defines the class and the high-level functionality common to all classes

*** DONE Adwin driver-global constants
As previously stated the base-class  parameters hold information necessary for the ADwin instrument to work and some of the instrument characterization constants. The parameters are:
- ADDRESS :: The address is the associated to the port used to communicate with the instrument.
- BOOT_SCRIPT_DFLT :: This parameter has the location of the boot script used to load the operative system of the ADwin instrument.
- PROGRAM_DIR :: This parameter has the name of the subdirectory where all the ADwin specific files, including ADwin programs are stored,
- HIGH_PERIOD :: According to the manual the ADwin has a minimum time resolution of the clock period depending on the type of process involved. For high priority process  is \(25 [ns] \)
- OUTPUT_RANGE :: The output of the analog output is limited to \(\pm 10 [V]\), hence the range is \(10\).
- RESOLUTION :: The ADwin uses \(16\) bits to represent the values of the analog inputs and outputs, hence the resolution is \(16\)
- PROCESS_DELAY :: The process delay, is a parameter that counts how many periods of the instrument are considered between different steps of a process. Considering the period for a high priority process, it was decided to perform an operation with the instrument only once every  \(10 [\mu s]\), hence the process delay is set to \(400\)

#+BEGIN_SRC python
  ###########################################################################
  ## @class  ADW_GCONST
  #  @brief  Parameters for Adwin instrument
  #
  #  @details This is the list of parameters used by the ADwin
  #           ADDRESS -> Communication address with the ADwin
  #           BOOT_SCRIPT_DFLT -> Where is the operative system
  #           PROGRAM_DIR -> The directory where all adwin files are stored
  #           HIGH_PERIOD -> high priority process clock period (25 ns)
  #           OUTPUT_RANGE -> Output voltage in volts (+- 10 v)
  #           RESOLUTION -> 16 bits of representation for continous values
  #           IV_PROCESS -> IV measurements program stored in slot 1
  #           HIST_PROCESS -> Histogram program stored in slot 2
  #           PROCESS_DELAY -> number of ADwin clock between each operation
  #                            set to 400, in order to operate every 10 us
  ###########################################################################
  class ADW_GCONST:
      # Interface with computer
      ADDRESS = 0x150
      BOOT_SCRIPT_DFLT = 'C:\ADwin\ADwin9.btl'
      PROGRAM_DIR = "adwin_programs"
      # Adwin instrument characterization
      HIGH_PERIOD      = 25e-9
      OUTPUT_RANGE     = 10.0
      RESOLUTION       = 16.0
      # Program Constants
      PROCESS_DELAY    = 400
#+END_SRC

*** TODO Adwin driver-base class Interface
The Adwin driver interface provides the basic functionality needed to interact with the ADwin instrument, which is the bare minimum. The idea is that each process should have it's own specialized driver.
Is important to note that any parameter used by this abstract driver, should be a global Adwin parameter. See

#+BEGIN_SRC python
  ############################################################
  ## @class   adwin_driver
  #  @details This class initializes the driver without
  #           any particular purpose. This is the parent class
  #           and user should use this only when designing a
  #           new measurement method
  ############################################################
  class adwin_driver(object):
      #############################################################
      ## @brief   Initilaization code
      #############################################################
      def __init__(self):
          self._adwin_subdir= ADW_GCONST.PROGRAM_DIR
          self.adw = ADwin.ADwin(ADW_GCONST.ADDRESS,1)
          self.adw.Boot(ADW_GCONST.BOOT_SCRIPT_DFLT)
      #############################################################
      ## @brief   Load the measurement program. Basic interface
      #############################################################
      def load_process(self, filename):
          root_path = utl.get_script_root_path()
          program_path = os.path.join(root_path,self._adwin_subdir)
          process_file = os.path.join(program_path,filename)
          if (os.path.isfile(process_file)):
              self.adw.Load_Process(process_file)
          else :
              raise Exception("Bad file, check %s" %process_file)
      #############################################################
      ## @brief   Starts the measurement process
      #############################################################
      def start_process(self, process_number):
          self.adw.Start_Process(process_number)
      #############################################################
      ## @brief   Stop the measurement process
      #############################################################
      def stop_process(self, process_number):
          self.adw.Stop_Process(process_number)
      #############################################################
      ## @brief   Show information on the adwin and process
      #############################################################
      def analyze(self, process_number):
          version = self.adw.Test_Version()
          processor = self.adw.Processor_Type()
          status = self.Process_Status(process_number)
          print("Version %s " % name)
          print("Processor type: %s " % name)
          self.print_status(status, process_number)
      #############################################################
      ## @brief   Minor utility to print the status information
      #############################################################
      def print_status(status, process_number):
          if (status == 0):
              print("Process %1.0f is not running" % process_number)
          if status == 1:
              print("Process %1.0f is running" % process_number)
          if status < 0:
              print("Process %1.0f is stopped" % process_number)
#+END_SRC
** TODO Adwin driver-IV measurement class
The Adwin IV measurement class provides a single interface, which controls the process to perform continuous measurements of the current/voltage characteristics of the sample,  while providing a high level interface to interact with the instrument. To define the class we need
- Parameters :: Defined in [[Adwin driver-IV parameters]]. These parameters define the indices required to interact with the internal program.
- Driver class :: Defined in  [[Adwin IV-measurement driver]]. This is the class definition which provides with the necessary interface to interact with the instrument.

*** DONE Adwin driver-IV parameters
The Adwin instrument, stores its internal variables in predefined variables, which can be queried through an external program such as the driver defined in  [[Adwin IV-measurement driver]].  These variables are classified as:

- Int variables :: Defined in [[Adwin driver-IV int parameter]]. These correspond to integer variables.
- Float variables :: Defined in [[Adwin driver-IV int parameter]]. These correspond to  float variables.
- Array variables ::  Defined in [[Adwin driver-IV int parameter]]. These correspond to array variables.

The variables are identified with an index according to the instrument documentation. We also need to define the process number used by the ADwin program for the IV measurements.

#+CAPTION: Top level view of the Adwin parameters and related constants. For details see the corresponding sections
#+name: src-adwin-parameters
#+BEGIN_SRC python
  class ADW_IV_CONST:
        PROCESS_NUMBER = 1
        <<src-adwin-iv-param>>
        <<src-adwin-iv-fparam>>
        <<src-adwin-iv-aparam>>

#+END_SRC

**** DONE Adwin driver-IV int parameters
The Int parameters are used to define the indices to the corresponding integer variables in the internal ADwin memory used for communication. The variables used are:
- START_JV :: Used for setting the initial juncture voltage (off). The value should be set to an equivalent of \(0[V]\)
- MEASURE_JV ::  Used for setting the Juncture voltage set during measurements
- END_JV :: Used for setting the juncture voltage at end of measurements, like the starting voltage should be set to \(0[V]\)
- WAIT   :: Used for setting  the number of cycles to wait before measuring the current, after reaching the desired juncture voltage
- MAX_DATA :: Used for setting the maximum number of data points to measure. After reaching the target value, the measurements should stop
- ABORT ::  Used ad the parameter used to  abort measurements early
- END_STATUS :: Parameter used to communicate that measurements have ended.

#+CAPTION: <<src-adwin-iv-param>> Adwin parameter indices used for communicating the int variables with the instrument for IV parameter measurements
#+NAME: src-adwin-iv-param
#+BEGIN_SRC python :tangle no
  ###########################################################################
  ## @brief  Indices  for int vars in ADwin used for IV measurements
  ###########################################################################
  # Inputs for the ADWIN IV measurement
  START_JV    = 1
  MEASURE_JV  = 2
  END_JV      = 3
  WAIT        = 7
  AVG         = 8
  MAX_DATA    = 10
  ABORT       = 11
  # outputs for the ADWIN IV measurement
  END_STATUS  = 12
#+END_SRC
**** DONE Adwin driver-IV float parameters
The float parameters are used to define the indices to the corresponding float variables in the internal ADwin memory used for communication. The variables used are:
- I_CH1      :: Float variable used to store the current measured in channel 1
- I_CH1_AMPL :: Float variable used to store the current measured in channel 1 with log amplifier
- I_CH2      :: Float variable used to store the current measured in channel 1
- I_CH2_AMPL :: Float variable used to store the current measured in channel 1 with log amplifier

#+CAPTION: <<src-adwin-iv-fparam>> Adwin parameter indices used for communicating the float variables with the instrument for IV parameter measurements
#+NAME: src-adwin-iv-fparam
#+BEGIN_SRC python :tangle no
  ###########################################################################
  ## @brief  Indices  for float vars in ADwin used for IV measurements.
  ###########################################################################
  # output variables for measured currents for the ADWIN IV measurement
  I_CH1       = 1
  I_CH1_AMPL  = 2
  I_CH2       = 3
  I_CH2_AMPL  = 4
#+END_SRC
**** DONE Adwin driver-IV array parameters
The array  parameters are used to define the indices to the corresponding array variables in the internal ADwin memory used for communication. The variables used in this process are:
- LOG_AMP ::  Used to provide  the logarithmic amplifier calibration array

#+CAPTION: <<src-adwin-iv-aparam>> Adwin parameter indices used for communicating the array variables with the instrument for IV parameter measurements
#+NAME: src-adwin-iv-aparam
#+BEGIN_SRC python :tangle no
  ###########################################################################
  ## @brief  Indices  for array vars in ADwin used for IV measurements
  ###########################################################################
  # ----------------------------- inputs  ------------------------------
  LOG_AMPL  = 10
#+END_SRC

*** TODO Adwin IV-measurement driver
This driver provides the functionality required to perform the measurements using the IV-measurement process, which is to perform continuous measures and provide an interface to query the current state (See [[Adwin Measure IV process]]). This process is designed to be used in conjunction with the Faulhaber part of the process (See [[Faulhaber driver]]).

As usual with this type of definitions, the code is split in logical blocks; in this case:
- Initialization code :: The code required to initialize the class and instantiate it as a user. See [[Adwin IV driver-Initialization Code]]
- API :: Or the functions that a user should use in order to query the information from the instrument. See [[Adwin IV driver-interface functions]]

**** TODO Adwin IV driver-Initialization Code
Code fragment [[adwin-driver-iv-interface]] shows the initialization code for the IV-measurements, in which some specializations are used over the base class in the =__init__=, where the function =configure_process= shown in line [[(adw-iv-configure)]] , which ensures that every parameter and variable needed for performing the measurements is correctly initialized
#+Caption: <<adwin-driver-iv-interface>> Code fragment with the base definition for the iv measurements
#+name: src-adwin-driver-iv-interface
#+BEGIN_SRC python
  ############################################################
  ## @class   adwin_iv_driver
  #  @details This class initializes the driver with the
  #           the purpose of performing continuos IV
  #           measurements.
  #           The class provides the interfaces to extract
  #           the data as necesary
  ############################################################
  class adwin_iv_driver(adwin_driver):
      #############################################################
      ## @brief   Initilaization code
      #############################################################
      def __init__(self, config):
          super(adwin_iv_driver).__init__()
          self.load_process()
          self.configure_process(config)
          self.config = config
      #############################################################
      ## @brief   Load the IV measurement program.
      #############################################################
      def load_process(self):
          filename = "iv_measurement_process.T".format(ADW_IV_CONST.PROCESS_NUMBER)
          super(adwin_iv_driver).load_process(filename)
      #############################################################
      ## @brief   Starts the measurement process
      #############################################################
      def start_process(self):
          super(adwin_iv_driver).start_process(ADW_IV_CONST.PROCESS_NUMBER)
      #############################################################
      ## @brief   Stop the measurement process
      #############################################################
      def stop_process(self):
          super(adwin_iv_driver).stop_process(ADW_IV_CONST.PROCESS_NUMBER)
      #############################################################
      ## @brief   Print debug information if necessary
      #############################################################
      def analyze(self):
          super(adwin_iv_driver).analyze(ADW_IV_CONST.PROCESS_NUMBER)
      #############################################################
      ## @brief   Set all parameters to start measuring
      #############################################################
      def configure_process(self): #  (ref:adw-iv-configure)
          c = self.config
          log_array = c.get_log_array()
          length = len(log_array)
          self.adw.Set_Processdelay(ADW_IV_CONST.PROCESS_NUMBER,
                                    ADW_GCONST.PROCES_DELAY )
          self.adw.SetDataFloat(log_array,
                                ADW_IV_CONST.LOG_AMPL,1,length)
          self.adw.Set_Par(ADW_IV_CONST.START_JV, c.get_start_jv())
          self.adw.Set_Par(ADW_IV_CONST.MEASURE_JV, c.get_measure_jv())
          self.adw.Set_Par(ADW_IV_CONST.END_JV, c.get_end_jv())
          self.adw.Set_Par(ADW_IV_CONST.WAIT, c.get_wait_cycles())
          self.adw.Set_Par(ADW_IV_CONST.AVG, c.get_avg_points())
          self.adw.Set_Par(ADW_IV_CONST.MAX_DATA, c.get_max_data())
      <<src-adwin-iv-driver-api>>
#+END_SRC

**** TODO Adwin IV driver-interface functions
     :PROPERTIES:
     :header-args+: :tangle no
     :END:
This section provides with the functions required to obtain the measurements from the instrument. The main functionality is to obtain the conductance measurement, as a fraction of the "1 Gold atom conductance" usually noted as *G0*
#+name: src-adwin-iv-driver-api
#+BEGIN_SRC python
  #############################################################
  ## @brief   Return the current measured by the ADwin
  #############################################################
  def get_current(self):
      if self.config.get_use_log_ampl() :
          current = self.adw.getFPar(ADW_IV_CONST.I_CH1_AMPL)
      else :
          digital_current = self.adw.getFPar(ADW_IV_CONST.I_CH1)
          current = adwin_DAC_value(digital_current) /self.config.linear_gain
      return current
  #############################################################
  ## @brief   Return the conductance measured by the ADwin
  #############################################################
  def get_real_conductance(self):
      return self.get_current()/self.config.get_real_jv()
  #############################################################
  ## @brief   Return the conductance as a "G0" factor measured
  #############################################################
  def get_conductance(self):
      return self.get_real_conductance()/param.GLOBAL_CONSTANTS.G0
#+END_SRC

** TODO Adwin driver-histogram class
*** DONE Adwin driver-histogram parameters
In a similar way as shown in [[Adwin driver-IV parameters]] the parameters are grouped in 3 categories

- Int variables :: shown in code fragment [[src-adwin-hist-param]] These correspond to the indices for the integer variables.
- Float variables :: shown in code fragment [[src-adwin-hist-fparam]] These correspond to the indices for the float variables.
- Array variables :: shown in code fragment [[src-adwin-hist-aparam]] These correspond to the indices for the array variables.

#+BEGIN_SRC python
  class ADW_HIST_CONST:
      PROCESS_NUMBER = 2
      <<src-adwin-hist-param>>
      <<src-adwin-hist-fparam>>
      <<src-adwin-hist-aparam>>
#+END_SRC
**** DONE Adwin driver-histogram int parameters
The Int parameters are used to define the indices to the corresponding integer variables in the internal ADwin memory used for communication. The variables used are:
- START_JV :: Used for setting the initial juncture voltage (off). The value should be set to an equivalent of \(0[V]\)
- MEASURE_JV ::  Used for setting the Juncture voltage set during measurements
- END_JV :: Used for setting the juncture voltage at end of measurements, like the starting voltage should be set to \(0[V]\)
- BREAK_WAIT   :: Used for setting  the number of cycles to wait before measuring the current, after modifying the piezoelectric voltage during the breaking analysis, and in turn the position of the piezoelectric. This time is considered as a stabilization time, to avoid measuring before the piezoelectric is stable in its new position
- MAKE_WAIT   :: Used for setting  the number of cycles to wait before measuring the current, after modifying the piezoelectric voltage during the make histogram analysis. As with the *BREAK_WAIT* this is considered a stabilization time.
- AVG :: Used as the index to set the number of measurements to be performed before taking an average in each piezoelectric point.
- BREAK_IDX  ::  Used as the variable where the length of the array of break-histogram is stored and read by the program .
- MAKE_IDX  ::  Used as the variable where the length of the array of break-histogram is stored and read by the program .

#+CAPTION: <<src-adwin-hist-param>> Adwin parameter indices used for communicating the int variables with the instrument for the histogram measurements
#+NAME: src-adwin-hist-param
#+BEGIN_SRC python :tangle no
  ###########################################################################
  ## @brief  Indices  for int vars with ADwin for IV measurements
  ###########################################################################
  # Inputs for the ADWIN histogram measurement
  START_JV    = 1
  MEASURE_JV  = 2
  END_JV      = 3
  BREAK_WAIT  = 17
  MAKE_WAIT   = 18
  AVG         = 19
  # outputs for the ADWIN histogram measurement
  END_STATUS  = 12
  ERROR_STATUS  = 13
  BREAK_IDX   = 20
  MAKE_IDX    = 21
#+END_SRC

**** DONE Adwin driver-histogram float parameters
The float parameters are used to define the indices to the corresponding float variables in the internal ADwin memory used for communication. The variables used are:
- I_MIN_BRK  :: Variable used to set the minimum expected current during breaking
- I_MAX_MK   :: Variable used to set the maximum expected current during making

#+CAPTION: <<src-adwin-hist-fparam>> Adwin parameter indices used for communicating the float variables with the instrument for the histogram measurements
#+NAME: src-adwin-hist-fparam
#+BEGIN_SRC python :tangle no
  ###########################################################################
  ## @brief  Indices  for float vars with ADwin for IV measurements
  ###########################################################################
  # inputs for the ADWIN histogram measurement
  I_MIN_BRK  = 10
  I_MAX_MK   = 11
#+END_SRC

**** DONE Adwin driver-histogram array parameters
The array  parameters are used to define the indices to the corresponding array variables in the internal ADwin memory used for communication. The variables used in this process are:
- LOG_AMP ::  Used to provide  the logarithmic amplifier calibration array
- BRK_HIST :: Index of the ADwin data array used for storing the  breaking histogram
- MK_HIST  :: Index of the ADwin data array used for storing the make histogram

#+CAPTION: Adwin parameter indices used for communicating the array variables with the instrument for histogram measurements
#+NAME: src-adwin-hist-aparam
#+BEGIN_SRC python :tangle no
  ###########################################################################
  ## @brief  Indices  for array vars with ADwin for IV measurements
  ###########################################################################
  # Inputs for the ADWIN histogram measurement
  LOG_AMPL  = 10
  # Outputs for the ADWIN histogram measurement. Histogram
  BRK_HIST  = 1
  BRK_VOLT  = 2
  MK_HIST   = 3
  MK_VOLT   = 4
#+END_SRC

*** TODO Adwin histogram-measurement driver
This driver provides the functionality required to perform the histogram measurements using the histogram process (See [[Adwin Measure-Generate piezo histogram]]), which is to perform continuous measures for different piezoelectric positions to generate the histogram. Naturally the driver provides with the interfaces to interact with the process at user level.

As usual with this type of definitions, the code is split in logical blocks; in this case:
- Initialization code :: The code required to initialize the class and instantiate it as a user. See [[Adwin histogram driver-Initialization Code]]
- API :: Or the functions that a user should use in order to query the information from the instrument. See [[Adwin histogram driver-interface functions]]
**** TODO Adwin histogram driver-Initialization Code
In a similar manner as used in [[Adwin IV driver-Initialization Code]] the code fragment [[src-adwin-hist-driver-init]], provides with the initialization code and corresponding configuration of the ADwin driver in order to perform the histogram measurement

#+CAPTION: <<src-adwin-hist-driver-init>>
#+NAME: src-adwin-hist-driver-init
#+BEGIN_SRC python
  ############################################################
  ## @class   adwin_hist_driver
  #  @details This class initializes the driver with the
  #           the purpose of performing histogram
  #           measurements.
  #           The class provides the interfaces to extract
  #           the data as necesary
  ############################################################
  class adwin_hist_driver(adwin_driver):
      #############################################################
      ## @brief   Initilaization code
      #############################################################
      def __init__(self,config):
          super(adwin_hist_driver).__init__()
          self.load_process()
          self.configure_process()
          self.config = config
      #############################################################
      ## @brief   Load the histogram  measurement program.
      #############################################################
      def load_process(self):
          filename = "hist_measurement_process.T%d" % ADW_HIST_CONST.PROCESS_NUMBER
          super(adwin_hist_driver).load_process(filename)
      #############################################################
      ## @brief   Starts the measurement process
      #############################################################
      def start_process(self):
          self.adw.Set_Par(ADW_HIST_CONST.ERROR_STATUS, 0)
          self.adw.Set_Par(ADW_HIST_CONST.END_STATUS, 0)
          super(adwin_hist_driver).start_process(ADW_HIST_CONST.PROCESS_NUMBER)
      #############################################################
      ## @brief   Stop the measurement process
      #############################################################
      def stop_process(self):
          super(adwin_hist_driver).stop_process(ADW_HIST_CONST.PROCESS_NUMBER)
      #############################################################
      ## @brief   Print debug information if necessary
      #############################################################
      def analyze(self):
          super(adwin_hist_driver).analyze(ADW_HIST_CONST.PROCESS_NUMBER)
      #############################################################
      ## @brief   Set all parameters to start measuring
      #############################################################
      def configure_process(self): #  (ref:adw-hist-configure)
          c = self.config
          log_array = c.get_log_array()
          length = len(log_array)
          self.adw.Set_Processdelay(ADW_HIST_CONST.PROCESS_NUMBER,
                                    ADW_GCONST.PROCES_DELAY )
          self.adw.SetDataFloat(log_array,
                                ADW_HIST_CONST.LOG_AMPL,1,length)
          self.adw.Set_Par(ADW_HIST_CONST.START_JV, c.get_start_jv())
          self.adw.Set_Par(ADW_HIST_CONST.MEASURE_JV, c.get_measure_jv())
          self.adw.Set_Par(ADW_HIST_CONST.END_JV, c.get_end_jv())
          self.adw.Set_Par(ADW_HIST_CONST.AVG, c.get_avg_points())
          self.adw.Set_Par(ADW_HIST_CONST.BREAK_WAIT, c.get_break_wait())
          self.adw.Set_Par(ADW_HIST_CONST.MAKE_WAIT, c.get_make_wait())
          self.adw.Set_Par(ADW_HIST_CONST.I_MIN_BRK, c.get_I_break_end())
          self.adw.Set_Par(ADW_HIST_CONST.I_MAX_BRK, c.get_I_make_end()) #
      <<src-adwin-hist-driver-api>>
#+END_SRC

**** TODO Adwin histogram driver-interface functions
     :PROPERTIES:
     :header-args+: :tangle no
     :END:
This section provides with the functions required to obtain the histogram measurements from the instrument. This fragment provides with the following interfaces:
- Process ended :: Queries the status variable from the ADwin and check if the status is the same as the one defined to be the end status
- Measure :: The meaure runs the adwin histogram process and wait untill the measurement is finished, then obtains the corresponding make and break histograms and returns them
- Make histogram :: Queries the data array from the ADwin that holds the make histogram and returns it
- Break histogram :: Queries the data array from the ADwin that holds the break histogram and returns it
#+name: src-adwin-hist-driver-api
#+BEGIN_SRC python

  def measure_and_get_histogram(self):
      self.start_process()
      while not self.process_ended() :
          state = self.adw.get_Par(ADW_HIST_CONST.STATE_PARAM)
          if state == 1:
              print("Run number: %1.0f \nbreaking 1"% x)
          if state == 2:
              print("Run number: %1.0f \nmaking 1"% x)
      os.system('cls')
      self.stop_process()
      break_histogram = self.get_break_histogram()
      make_histogram = self.get_make_histogram()

      return break_histogram, make_histogram

  def get_break_histogram(self):
      length = self.adw.Get_Par(ADW_HIST_CONST.BREAK_IDX) -1
      current_hist = self.adw.GetData_Float(ADW_HIST_CONST.BRK_HIST, 1, length)
      conductance_hist = current_hist/(self.config.measure_jv * self.config.G0) #TODO FIX
      ret_hist = convert_to_list_float(conductance_hist)
      return ret_hist

  def get_break_voltage(self):
      length = self.adw.Get_Par(ADW_HIST_CONST.BREAK_IDX) -1
      voltage_hist = self.adw.GetData_Float(ADW_HIST_CONST.BRK_VOLT, 1, length)
      new_voltage_hist = np.zeros(length)
      for idx in range(length):
          new_v = convert_bin_to_v(voltage_hist[idx])
          new_voltage_hist[idx] = new_v
      ret_hist = convert_to_list_float(new_voltage_hist)
      return ret_hist

  def get_make_histogram(self):
      length = self.adw.Get_Par(ADW_HIST_CONST.MAKE_IDX) -1
      current_hist = self.adw.GetData_Float(ADW_HIST_CONST.MK_HIST, 1, length)
      conductance_hist = current_hist/(self.config.measure_jv * self.config.G0) #TODO FIX
      ret_hist = convert_to_list_float(conductance_hist)
      return ret_hist

  def get_make_voltage(self):
      length = self.adw.Get_Par(ADW_HIST_CONST.MK_IDX) -1
      voltage_hist = self.adw.GetData_Float(ADW_HIST_CONST.MK_VOLT, 1, length)
      new_voltage_hist = np.zeros(length)
      for idx in range(length):
          new_v = convert_bin_to_v(voltage_hist[idx])
          new_voltage_hist[idx] = new_v
      ret_hist = convert_to_list_float(new_voltage_hist)
      return ret_hist

  def process_ended():
      return self.adw.Get_Par(ADW_HIST_CONST.END_STATUS) == 2
  def measurement_without_errors(self):
      return not self.adw.Get_Par(ADW_HIST_CONST.ERROR_STATUS) == 0
  def error_in_breaking(self):
      return self.adw.Get_Par(ADW_HIST_CONST.ERROR_STATUS) & 1 == 1
  def error_in_making(self):
      return (self.adw.Get_Par(ADW_HIST_CONST.ERROR_STATUS) >> 1) & 1 == 1
#+END_SRC

*** TODO ADwin Histogram test                                      :noexport:
    :PROPERTIES:
    :header-args+: :tangle modules/adwin_histogram_test.py
    :END:
Small test program for the ADwin hisotgram measurement.
#+BEGIN_SRC python
  from adwin_histogram import *

  def convert_v_to_bin(V):
      output_range = ADW_GCONST.OUTPUT_RANGE
      resolution = ADW_GCONST.RESOLUTION
      bin_v,real_v =convert_V_to_bin(V,output_range,resolution)
      return real_v

  def wait_from_speed(speed):
      mod_speed = speed/100
      scanrate = 1/ADW_GCONST.PROCESS_DELAY
      steps = 2*ADW_GCONST.OUTPUT_RANGE/ 2**ADW_GCONST.RESOLUTION
      wait = int(scanrate/mod_speed/steps)


  class adwin_histogram_config:
      start_jv = 0
      measure_jv = convert_v_to_bin(0.1)
      end_jv = 0
      break_wait = wait_from_speed(300)
      make_wait = wait_from_speed(500)
      num_avg = 32
      G0 = 7.74809173e-5
      min_i_brk = 7.74809173e-5 * 10 * convert_v_to_bin(0.1)
      max_i_brk = 7.74809173e-5 * 30 * convert_v_to_bin(0.1)

  class adw_display:
      number_traces = 5000
      nGbins = 251
      nDbins = 161
      xmin = -0.5 # nm
      xmax = 2    # nm
      Gmin = 1e-7 # G0
      Gmax = 10   # G0


  def plot_traces(axis, D_breaking, G_breaking, D_making, G_making):
      axis.clear()
      plt_breaking =  axis.plot(D_breaking,G_breaking,linewidth=2)
      plt_making =  axis.plot(D_making,G_making,linewidth=2)
      axis.set_yscale("log")
      axis.set_xlim(0, max(max(D_making),max(D_breaking)))
      axis.set_ylim(adw_display.Gmin, adw_display.Gmax)
      axis.set_title("Conductance trace")
      axis.set_xlabel('Displacement (nm)')
      axis.set_ylabel('Conductance (G0)')
      axis.set_aspect(1)
      #axis.xticks(power(zeros(nGbins) + 10.0, range(-8,2,4)))
      #axis.yticks(range(-10,1,10))

  def plot_counts(axis, break_acc, make_acc, G_breaking, G_making, G_bins, D_bins):
      tmp=np.histogram(G_breaking, bins=Gbins)
      break_acc = break_acc + tmp[0]
      tmp=np.histogram(G_making, bins=Gbins)
      make_acc = make_acc + tmp[0]
      # plot 1D histogram (2)
      Gbins_plot = Gbins[0:-1]
      Dbins_plot = Dbins[0:-1]
      axis.clear()
      plt_histo1D_breaking =  axis.plot(Gbins_plot, break_acc,linewidth=2)
      plt_histo1D_making =  axis.plot(Gbins_plot,make_acc,linewidth=2)
      axis.set_xscale("log")
      axis.set_ylim(0, 1.2*max(max(break_acc),max(make_acc)))
      axis.set_xlim(Gbins[0], Gbins[-1])
      axis.set_title("1D Histogram")
      axis.set_ylabel('Counts')
      axis.set_xlabel('Conductance (G0)')
      axis.set_aspect(1)

      return break_acc, make_acc


  def plot_2d_histogram(axis, G_breaking, G_making, G_bins, D_bins):
      index=max(find(G_breaking>0.5))
      D_breaking = D_breaking - D_breaking[index]

      # plot 2D histogram (3)
      tmp = histogram2d(G_breaking, D_breaking, bins=(Gbins, Dbins))
      histo2D_breaking_sum = histo2D_breaking_sum + tmp[0]

      index1 = find(min(abs(log10(Gbins) - -2 ))==(abs(log10(Gbins) - -2 )))
      index2 = find(min(abs(log10(Gbins) - -6 ))==(abs(log10(Gbins) - -6 )))
      tmp = histo2D_breaking_sum[index2:index1,:]

      Cmax = 0
      for y in range(0,index1-index2):
          Cmax = max(max(tmp[y,:]), Cmax)

      axis.clear()
      surf = axis.contourf(Dbins_plot, Gbins_plot, histo2D_breaking_sum, linspace(0,Cmax/2,16))
      axis.set_yscale("log")
      axis.set_ylim(Gbins_plot[0], Gbins_plot[-1])
      axis.set_xlim(Dbins_plot[0], Dbins_plot[-1])
      axis.set_title("2D Histogram")
      axis.set_xlabel('Displacement (nm)')
      axis.set_ylabel('Conductance (G0)')

      pause(1)

  def stop():
      """stop ADwin and motor"""
      ADwin_stop_all_process()
      ADwin_boot()
      Faulhaber_command('v 0')
  # Configure Plot

  ## initialize histogram
  Gbins = power(zeros(nGbins) + 10.0, linspace(log10(Gmin), log10(Gmax), nGbins)) # create conductance array
  Dbins = linspace(xmin, xmax, nDbins) # create displacement array

  histo1D_breaking_sum = zeros(nGbins-1)
  histo1D_making_sum = zeros(nGbins-1)
  histo2D_breaking_sum = zeros(shape=(nGbins-1,nDbins-1))

  ## plot settings
  rcParams['figure.figsize'] = [22, 10]
  font = {'family' : 'normal',
          'weight' : 'normal',
          'size'   : 22}
  fig, (ax1, ax2, ax3) = plt.subplots(1, 3)
  ax1.set_position([0.07, 0.1, 0.25, 0.8])
  ax2.set_position([0.39, 0.1, 0.25, 0.8])
  ax3.set_position([0.72, 0.1, 0.25, 0.8])
  fig.set_facecolor('white')
  matplotlib.rc('font', **font)

  adw = adwin_histogram_driver(adwin_histogram_config)
  date = strftime("%y%m%d")
  for i in range(adw_display.num_traces):
      break_histogram, make_histogram = adw.measure_and_get_histogram()
      if adw.error_in_measurement() :
          continue
      D_breaking = break_histogram[0]
      G_breaking = break_histogram[1]

      D_making = make_histogram[0]
      G_making = make_histogram[1]

      plot_traces(ax1, D_breaking, G_breaking, D_making, G_making):
      break_acc, make_acc = plot_counts(ax2, break_acc, make_acc, G_breaking, G_making, G_bins, D_bins)
      plot_2d_histogram(ax2, G_breaking, G_making, G_bins, D_bins):

      filename = save_dir + 'scan_jf' + date + '_' + "%1.0f.dat" % x
      file = open(filename, "w")
      #make_general_header(file)
      make_piezo_header(file)
      save_data(file, D_breaking, G_breaking)
      save_data(file, D_making, G_making)
      file.close()

#+END_SRC

** TODO Adwin driver-utilities
There are several functionalities that are tied to the ADwin intrument but do not belong to it.

*** TODO Adwin converters
The Adwin can perform DAC conversion at its output. Is this conversion used for setting the output voltages of the instrument, either to control the Piezoelectric device or to set the juncture voltage. However the instrument cannot be configured with any values, so in order to set the target values in the instrument, we need to perform the same process with the driver and pass the instrument with the corresponding digital value.

In summary, to set a value in the Adwin we need to take the target value, and convert it to digital representation within the ADwin constraints; similarly we need to be able to convert a digital representation back to regular values.

#+BEGIN_SRC python
  def adwin_ADC(analog_value):
      # converts ADC/DAC voltage to bin number, given the voltage range and the ADW_GCONST.RESOLUTION as int (adwin digitia representation)
      step=2*ADW_GCONST.OUTPUT_RANGE/(2**ADW_GCONST.RESOLUTION-1)
      voltage=np.arange(-ADW_GCONST.OUTPUT_RANGE, ADW_GCONST.OUTPUT_RANGE+step, step)
      try:
          l = len(V)
          N_bin = zeros(l)
          for i in range(0,len(V)):
              diff = abs(voltage-V[i])
              N_bin[i] = diff.argmin()
      except:
          diff = abs(voltage - V)
          N_bin = diff.argmin()

      return N_bin, convert_bin_to_V(N_bin)

  def adwin_DAC(digital_value):
      # converts ADC/DAC bins to voltage, given the voltage range and the resolution (in bits)
      step = 2 * ADW_GCONST.OUTPUT_RANGE / (2**ADW_GCONST.RESOLUTION-1)
      voltage = np.arange(-ADW_GCONST.OUTPUT_RANGE, ADW_GCONST.OUTPUT_RANGE+step, step)
      try:
          N_bin = int(N_bin)
          data = voltage[N_bin]
      except:
          data=zeros(len(N_bin))
          for i in range(0,len(N_bin)):
             data[i]=voltage[N_bin[i]]

      return data

  def adwin_ADC_DAC_roundtrip(analog_value):
      return adwin_DAC(adwin_ADC(analog_value))


  def adwin_convert_ms_to_cycles(time):
      # Stabilization cycles before starting measurement
      # Wait is in ms, but we need to wait number of cycles.
      # Each cycle is 10 us => wait/cycle_time
      cycle_time = ADW_GCONST.HIGH_PERIOD * ADW_GCONST.PROCESS_DELAY
      wait_cycles = int(self.wait*1e-3 /cycle_time ) # Because ms
#+END_SRC


* DONE Adwin Measurements
  :PROPERTIES:
  :header-args+: :comments noweb
  :END:
The Adwin instrument is capable of controlling the piezo actuator and to take measurements by using its several hardware interfaces. Thus is the ADwin which actually performs the measurements by using different *process* or sub-routines, written in basic, and then handing the data back to the main program. These sub-routines must be compiled and then loaded into the instrument, so any program that process the data, is reduced to query the results of the measurements.

For the measurements required in the break-junction experiment the following process have been identified:
- Juncture Voltage Measurement :: This process is used to measure the voltage  and current on the juncture, periodically for a given time. See [[Adwin%20Measure%20IV%20process][Adwin Measure IV process]]
- Juncture Voltage Histogram :: This process uses some of the same sub-routines to measure the voltage and current on the juncture, but perform the same measurement several times as it also actuates on the piezoelectric actuator to perform the breaking and joining of the juncture. See [[Adwin%20Measure%20-%20Generate%20piezo%20histogram][Adwin Measure-Generate piezo histogram]]

Beyond the basic programs that perform the measurements, an interface to the actual program is shown in [[Adwin driver-program interface]]

** DONE Adwin Measure IV process
   :PROPERTIES:
   :header-args+:  :tangle   adwin_programs/iv_measurement_process.bas
   :header-args+:  :noweb    tangle
   :header-args+:  :mkdirp   yes
   :END:
#+ATTR_LATEX: :width 0.9\textwidth
#+CAPTION: Measurement algorithm for the I/V at the ADwin
#+NAME: fig:adwin-measure-iv
[[file:Doc/Dia/Adwin_IV.png]]

The Adwin measure process is a basic program described here for ease of access. The program is heavily based on the original, with some minor modification for clarity or robustness.

The Adwin process is split in several blocks
- Header :: This is a requirement of a proper ADwin program. See [[Adwin IV-measurement header]]
- Variable Declaration :: For a proper program, the variables must be declared before the program blocks. See  [[Adwin IV-variable Declarations]]
- Init block :: Is used to initialize the values of the variables defined. See [[Adwin IV-Init Block]]
- Event Block :: The main part of the measurement algorithm. See [[Adwin IV-Event Block]]

*** DONE Adwin IV-measurement header
As in many programs, a header is required. In the Adwin case, this is necessary  to set the process parameters, such as the process number and the compiler variables.

 #+BEGIN_SRC basic
   '<ADbasic Header, Headerversion 001.001>
   ' Process_Number                 = 1
   ' Initial_Processdelay           = 1000
   ' Eventsource                    = Timer
   ' Control_long_Delays_for_Stop   = No
   ' Priority                       = High
   ' Version                        = 1
   ' ADbasic_Version                = 5.0.8
   ' Optimize                       = Yes
   ' Optimize_Level                 = 1
   ' Info_Last_Save                 = TUD203025  TUD203025\LocalAdmin
   '<Header End>

   ' This program provides a continous measurement of the current at the sample
   ' driven by the set voltage. In order to interface with the computer several
   ' ADwin static variables are used

#+END_SRC

#+BEGIN_SRC basic :exports none
  '*******
  ' Inputs: Set by external program
  '*******
  ' ---- Juncture Voltage Parameters ----
  ' PAR_1 -> Initial juncture voltage (off)
  ' PAR_2 -> Juncture voltage for measurement
  ' PAR_3 -> Juncture voltage at end (off)
  ' ---- Current Measurement ----
  ' PAR_7 -> Number of loops to wait after reaching desired juncture
  '          voltage before starting measuremnts
  ' PAR_8 -> Number of data point to average for current measurement
  ' ---- Measurement Modifiers ----
  ' PAR_10 -> Maximum number of data points to gather
  ' PAR_11 -> Set to 1 to finish the run early
  ' ---- Logaritmic amplifier ----
  ' DATA_10 -> The calibration data for the logaritmic amplifier

  '******
  ' Outputs
  '******
  ' ---- Current Measurements ----
  ' FPAR_1 -> Current measured in channel 1
  ' FPAR_2 -> Current measured in channel 1 through Amplifier
  ' FPAR_3 -> Current measured in channel 2
  ' FPAR_4 -> Current measured in channel 2 through Amplifier
  ' ---- Measurement end ----
  ' PAR_12 -> Set to 2 when the measurement process is finished


  '******
  ' Aux variables
  '******
  ' state -> Used to select the measurement process
  ' waitcounter -> Used to wait for stabilization before measuring (JV)
  ' avgcounter -> Used to select how many points will be averaged
  ' datacounter -> Used to count how many data points will be stored in total
  ' juncture_voltage -> Corrent juncture voultage at DAC
  ' current_acc -> Variables to store the accumulated value for averaging
  ' current_ampl_acc -> Same as before, but measured through log-amplifier
 #+END_SRC

*** DONE Adwin IV-variable Declarations
In an Adwin program the local variables must be declared before the =INIT= block. This program defines several internal variables to deal with the state.
#+CAPTION: Variable declarations
#+NAME: src-adwin-iv-declarations
#+BEGIN_SRC basic
DIM measuflag as long
DIM waitcounter, avgcounter, datacounter  as long
DIM juncture_voltage as long
DIM current1_acc, current2_acc as long
DIM current1_ampl_acc, current2_ampl_acc as float
' Set DATA_10 as amplifier array
DIM DATA_10[65536] as float
#+END_SRC

*** DONE Adwin IV-Init Block
In the ADwin =INIT= block the variables defined are set to their default values.
#+CAPTION: Adwin I/V analysis =INIT= block
#+NAME: src-adwin-iv-init
#+BEGIN_SRC basic
  state = 0
  waitcounter = 0
  avgcounter = 0
  datacounter = 0
  current1_acc = 0
  current2_acc = 0
  current1_amp_acc = 0
  current2_amp_acc = 0
  ' Set juncture voltage at output and prepare measurement
  juncture_voltage = PAR_1
  DAC(1, juncture_voltage)
  set_MUX(1010000000b) 'use MUX
#+END_SRC

*** DONE Adwin IV-Event Block

The =EVENT= block implements the measurement process. Since the =EVENT= block is excecuted perdiodically, at defined time intervals, the full algorithm must be implemented in a single =EVENT= block, which is managed by using state variables.

The =Event= Block is separated in different functionalities
- Set the juncture voltage :: Is necessary to perform the measurements. See [[Adwin IV-Event set juncture voltage]]
- Wait for stabilization :: After the juncture voltage is set, the measurements are delayed to wait for the system to stabilize itself. See [[Adwin IV-Event stabilize system]]
- Measure :: After the system has stabilized, at each run of the =EVENT= block, the system performs the measurement process by measuring a number of data points and averaging them. See [[Adwin IV-Event measure data]]
- Reset juncture voltage :: After the measurements have ended, the juncture voltage is returned to the off value. See [[Adwin IV-Event reset juncture voltage]]

#+CAPTION: Event loop
#+NAME: src-adwin-iv-event
#+BEGIN_SRC basic
  EVENT:

    SELECTCASE state
      CASE 0 'output desired voltage on DAC1
        <<src-adwin-iv-set-jv>>

      CASE 1 ' Wait untill stabilization
        <<src-adwin-iv-wait>>

      CASE 2 ' Measure
        <<src-adwin-iv-measure>>

      CASE 3 'ramp down to end voltage
        <<src-adwin-iv-reset-jv>>

    ENDSELECT
#+END_SRC

**** DONE Adwin IV-Event set juncture voltage
     :PROPERTIES:
     :header-args+:  :tangle   no
     :END:
#+CAPTION: <<src-adwin-iv-set-jv>> Code to set the juncture voltage  to the measurement required value
#+NAME: src-adwin-iv-set-jv
#+BEGIN_SRC basic
  ' PAR_2 -> Target juncture voltage
  IF(juncture_voltage < PAR_2) THEN INC(juncture_voltage)
  IF(juncture_voltage > PAR_2) THEN DEC(juncture_voltage)
  DAC(1,juncture_voltage)
  IF  (juncture_voltage = PAR_2) THEN state = 1
  ' state = 1 => we have to wait
#+END_SRC

**** DONE Adwin IV-Event stabilize system
     :PROPERTIES:
     :header-args+:  :tangle   no
     :END:
#+CAPTION: <<src-adwin-iv-wait>> Code to wait for the system to stabilize before staring measurements
#+NAME: src-adwin-iv-wait
#+BEGIN_SRC basic
  IF(waitcounter = PAR_7) THEN
    state = 2
  ELSE
    waitcounter = waitcounter + 1
  ENDIF
#+END_SRC
**** DONE Adwin IV-Event measure data
     :PROPERTIES:
     :header-args+:  :tangle   no
     :END:
#+CAPTION: <<src-adwin-iv-measure>> Code to measure the data
#+NAME: src-adwin-iv-measure
#+BEGIN_SRC basic
  START_CONV(00011b)
  WAIT_EOC(00011b)
  current1_acc = current1_acc + READADC(1)
  current2_acc = current2_acc + READADC(2)
  current1_ampl_acc = current1_ampl_acc + DATA_10[READADC(1)+1]
  current2_ampl_acc = current2_ampl_acc + DATA_10[READADC(2)+1]
  avgcounter = avgcounter + 1

  IF(avgcounter = PAR_8) THEN
    FPAR_1 = current1_acc / PAR_8
    FPAR_3 = current2_acc / PAR_8
    FPAR_2 = current1_ampl_acc / PAR_8
    FPAR_4 = current2_ampl_acc / PAR_8
    datacounter = datacounter + 1
    avgcounter = 0
    current1_acc = 0
    current2_acc = 0
    current1_amp_acc = 0
    current2_amp_acc = 0
  ENDIF

  IF (datacounter = PAR_10) THEN state = 3
  IF (PAR_11 = 1) THEN state =3
#+END_SRC
**** DONE Adwin IV-Event reset juncture voltage
     :PROPERTIES:
     :header-args+:  :tangle   no
     :END:
#+CAPTION: <<src-adwin-iv-reset-jv>> Code to restore the juncture value  to off value
#+NAME: src-adwin-iv-reset-jv
#+BEGIN_SRC basic
  IF(juncture_voltage < PAR_3 ) THEN INC(juncture_voltage)
  IF(juncture_voltage > PAR_3) THEN DEC(juncture_voltage)
  DAC(1,juncture_voltage)
  IF  (juncture_voltage = PAR_3) THEN PAR_12 = 2 ' check for end measurement
#+END_SRC

** DONE Adwin Measure-Generate piezo histogram
   :PROPERTIES:
   :header-args+:  :tangle   adwin_programs/piezo_histogram.bas
   :header-args+:  :noweb    tangle
   :END:
Since the Adwin controls the piezoelectric device and take measurements, it makes sense  to provide a single program that operates the piezoelectric device , and then takes the corresponding measurements for each setting. After all the measurements are taken, the data is stored for analysis in the external program. The histogram program is split in several groups, similarly as the ones shown in [[Adwin Measure IV process]].

- Header :: This is a requirement of a proper ADwin program. See [[Adwin histogram-measurement header]]
- Variable Declaration :: For a proper program, the variables must be declared before the program blocks. See  [[Adwin histogram-variable Declarations]]
- Init block :: Is used to initialize the values of the variables defined. See [[Adwin histogram-Init Block]]
- Event Block :: The main part of the measurement algorithm. See [[Adwin histogram-Event Block]]

*** DONE Adwin histogram-measurement header
As in many programs, a header is required. In the Adwin case, this is necessary  to set the process parameters, such as the process number and the compiler variables.

 #+BEGIN_SRC basic
   '<ADbasic Header, Headerversion 001.001>
   ' Process_Number                 = 2
   ' Initial_Processdelay           = 1000
   ' Eventsource                    = Timer
   ' Control_long_Delays_for_Stop   = No
   ' Priority                       = High
   ' Version                        = 1
   ' ADbasic_Version                = 5.0.8
   ' Optimize                       = Yes
   ' Optimize_Level                 = 1
   ' Info_Last_Save                 = TUD205822  TUD205822\LocalAdmin
   '<Header End>
#+END_SRC

#+BEGIN_SRC basic :exports none
  '*******
  ' Inputs: Set by external program
  '*******
  ' ---- Juncture Voltage Parameters ----
  ' PAR_1 -> Initial juncture voltage (off)
  ' PAR_2 -> Juncture voltage for measurement
  ' PAR_3 -> Juncture voltage at end (off)
  ' ---- Piezo Voltage ----
  ' PAR_5 -> Initial Piezo Voltage
  ' ---- Current Measurement ----
  ' PAR_17 -> Stabilizing time for breaking
  ' PAR_18 -> Stabilizing time for making
  ' PAR_19 -> Number of data point to average for each measurement
  ' ---- Measurement Modifiers ----
  ' FPAR_10 -> Minimum current to abort measurement - Breaking
  ' FPAR_11 -> Maximum current to abort measurement - Making
  ' ---- Amplifier -----
  ' DATA_10 -> Amplifier table for calibration

  '******
  ' Outputs
  '******
  ' ---- Measurement end ----
  ' PAR_12 -> Set to 2 when the measurement process is finished
  ' PAR_13 -> Set to 1 when there is a problem in the measurement
  ' ---- Current Measurements ----
  ' DATA_1 -> Array of measured currents for each data point -> breaking
  ' DATA_2 -> Array of set Piezo voltage for each data point -> breaking
  ' DATA_3 -> Array of measured currents for each data point -> making
  ' DATA_4 -> Array of set Piezo voltage for each data point -> making
  ' PAR_20 -> Final data point in  break histogram
  ' PAR_21 -> Final data point in  make histogram

  '******
  ' Aux Variables
  '******
  ' state -> Determines which process of the histogram is being used
  ' breakwait -> Used to wait for stabilization during breaking
  ' makewait -> Used to wait for stabilization during making
  ' avgcounter -> Used to count the measurements to average for a data point
  ' avgcurrent -> Auxiliar variable for average current
  ' juncture_voltage -> Current juncture_voltage at the DAC
  ' break_acc -> Accumulator for measurements during breaking
  ' make_acc -> Accumulator for measurements during making
  ' piezo_v -> Piezoelectric voltage
  ' piezo_min -> Minimum voltage to set in the piezo
  ' piezo_max -> Maximum voltage to set in the piezo
 #+END_SRC

*** DONE Adwin histogram-variable Declarations
In an Adwin program the local variables must be declared before the =INIT= block. This program defines several internal variables to deal with the state.
#+CAPTION: Variable declarations
#+NAME: src-adwin-hist-declarations
#+BEGIN_SRC basic
  DIM state as long
  DIM breakwait, makewait as long
  DIM avgcounter  as long
  DIM juncture_voltage as long
  DIM break_acc, make_acc  as long
  DIM piezo_V, piezo_min, piezo_max as long
  DIM avgcurrent as float
  ' Output histogram
  DIM histoindex_make histoindex_break as long
  DIM DATA_1[1048576] as float  'Break histogram
  DIM DATA_2[1048576] as float  'Make histogram
  ' Set DATA_10 as amplifier array
  DIM DATA_10[65536] as float
#+END_SRC

*** DONE Adwin histogram-Init Block
In the ADwin =INIT= block the variables defined are set to their default values.
#+CAPTION: Adwin histogram analysis =INIT= block
#+NAME: src-adwin-hist-init
#+BEGIN_SRC basic
  state = 0
  breakwait = 0
  makewait = 0
  avgcounter = 0
  avgcurrent = 0
  break_acc = 0
  make_acc = 0
  piezo_V = PAR_5
  piezo_min = 32771
  piezo_max = 65533
  PAR_20 = 1                      ' Break index
  PAR_21 = 1                      'Make index
  ' Set juncture voltage at output and prepare measurement
  juncture_voltage = PAR_1
  DAC(1, juncture_voltage)
  set_MUX(1010000000b) 'use MUX
#+END_SRC

*** DONE Adwin histogram-Event Block
#+ATTR_LATEX: :width 0.9\textwidth
#+CAPTION: Top level view of the measurement algorithm to generate the histogram with the ADwin
#+NAME: fig:adwin-histogram-top
[[file:Doc/Dia/Adwin_histogram_top.png]]

The =EVENT= block implements the measurement process. Since the =EVENT= block is excecuted perdiodically, at defined time intervals, the full algorithm must be implemented in a single =EVENT= block, which is managed by using state variables as shown in figure [[fig:adwin-histogram-top]]

The =Event= Block is separated in different functionalities
- Set the juncture voltage :: Is necessary to perform the measurements. See [[Adwin histogram-Event set juncture voltage]]
- Break Histogram :: After the juncture voltage is set, the Adwin perform the measurements breaking the juncture through the piezoelectric device in order to  create the break histogram. See [[Adwin histogram-Event break histogram]]
- Make Histogra :: After the juncture has been broken, The Adwin manipulates the piezoelectric backwards, reversing the broken juncture using it to create the make histogram. See [[Adwin histogram-Event make histogram]]
- Reset juncture voltage :: After the measurements have ended, the juncture voltage is returned to the off value. See [[Adwin histogram-Event reset juncture voltage]]

#+CAPTION: Event loop
#+NAME: src-adwin-histogram-event
#+BEGIN_SRC basic
  EVENT:

    SELECTCASE state
      CASE 0 'output desired voltage on DAC1
        <<src-adwin-hist-set-jv>>

      CASE 1 ' generate break histogram
        <<src-adwin-hist-break>>

      CASE 2 ' generate make histogram
        <<src-adwin-hist-make>>

      CASE 3 'ramp down to end voltage
        <<src-adwin-hist-reset-jv>>

    ENDSELECT
#+END_SRC

**** DONE Adwin histogram-Event set juncture voltage
     :PROPERTIES:
     :header-args+:  :tangle   no
     :END:
The algorithm to set the juncture voltage is the same as the one used for the IV measurement. See [[Adwin IV-Event set juncture voltage]]
#+CAPTION: <<src-adwin-hist-set-jv>> Code to set the juncture voltage  to the measurement required value
#+NAME: src-adwin-hist-set-jv
#+BEGIN_SRC basic :exports none
  <<src-adwin-iv-set-jv>>
#+END_SRC

**** DONE Adwin histogram-Event break histogram
     :PROPERTIES:
     :header-args+:  :tangle   no
     :END:
This section describes the algorithm used to store the break histogram shown in the code fragment [[src-adwin-hist-break]]. The algorithm is broken in 4 steps.
- Move the piezo :: Starting on line [[(adw-brk-pz)]] this is the first step  of the algorithm.
  - Increases the voltage on the piezo actuator in order to increase the "distance" between the the ends of the junction.
  - Since it's the first step of the algorithm is also used to cleanup the variables used during the histogram analysis.
  - Finally should the piezo voltage exceed a maximum voltage, then the histogram measurement is aborted  and the histogram proceeds to measuring the make histogram
- Wait for stabilization ::  Starting on line [[(adw-brk-wt)]] this step, only counts until a certain number of cycles have passed since the last modification of the piezo-voltage as to ensure the system is stable before measurement
- Measure data :: Starting on line [[(adw-brk-msr)]] this step performs several measurements of the current circulating through the junction storing the accumulated value. After a certain number of measurements have been made the process goues to the next step
- Store the Data :: Starting on line [[(adw-brk-store)]] this step takes the average of the accumulated value and stores it in the array. This process also:
  - Ensures that the current has not gone below a certain threshold in which case, the measurement stops  and the algorithm proceeds to the make histogram measurement
  - Updates the index so no values are overwritten

#+CAPTION: <<src-adwin-hist-break>> Code to generate the breaking histogram
#+NAME: src-adwin-hist-break
#+BEGIN_SRC basic -n -r
  SELECTCASE break_hist_flag
    CASE 0 ' Move piezo to new point (ref:adw-brk-pz)
      breakwait = 0
      avgcounter = 0
      break_acc = 0
      inc(piezo_V)
      IF (piezo_V >= piezo_max) THEN
        state = 2 ' Go to make histogram
        PAR_13 = 1
      ENDIF
      DAC(2,piezo_V)
      break_hist_flag = 1 ' Go to next stage

    CASE 1  ' Wait for stabilization (ref:adw-brk-wt)
      breakwait = breakwait + 1
      IF (breakwait >= PAR_17) THEN
        break_hist_flag = 2 ' Go to next stage
      ENDIF

    CASE 2  ' Measure data (ref:adw-brk-msr)
      START_CONV(00011b)
      WAIT_EOC(00011b)
      break_acc = break_acc + DATA_10[READADC(1)+1]
      avgcounter = avgcounter + 1
      IF (avgcounter  >= PAR_19) THEN
        break_hist_flag = 3 ' Go to next stage
      ENDIF

    CASE 3  ' Store average in array (ref:adw-brk-store)
      avgcurrent = break_acc / PAR_19
      DATA_1[PAR_20] = avgcurrent
      DATA_2[PAR_20] = piezo_V
      PAR_20 = PAR_20 + 1
      break_hist_flag = 0
      IF (avgcurrent <= FPAR_10) THEN
        state = 2 ' Go to make histogram
      ENDIF
#+END_SRC

**** DONE Adwin histogram-Event make histogram
     :PROPERTIES:
     :header-args+:  :tangle   no
     :END:
This section describes the algorithm used to store the make histogram shown in the code fragment [[src-adwin-hist-break]]. The algorithm is broken in 4 steps, in a similar fashion as done in [[Adwin histogram-Event break histogram]]
- Move the piezo :: Starting on line [[(adw-mk-pz)]] this is the first step  of the algorithm.
  - Decreases the voltage on the piezo actuator in order to reduce the "distance" between the the ends of the junction.
  - Since it's the first step of the algorithm is also used to cleanup the variables used during the histogram analysis.
  - Finally should the piezo voltage fall below a minimum voltage, then the make histogram measurement is aborted  and the algorithm proceeds to terminate the measurements
- Wait for stabilization ::  Starting on line [[(adw-mk-wt)]] this step, only counts until a certain number of cycles have passed since the last modification of the piezo-voltage as to ensure the system is stable before measurement
- Measure data :: Starting on line [[(adw-mk-msr)]] this step performs several measurements of the current circulating through the junction storing the accumulated value. After a certain number of measurements have been made the process goues to the next step
- Store the Data :: Starting on line [[(adw-mk-store)]] this step takes the average of the accumulated value and stores it in the array. This process also:
  - Updates the index so no values are overwritten

#+CAPTION: <<src-adwin-hist-make>> Code to build the break histogram
#+NAME: src-adwin-hist-make
#+BEGIN_SRC basic
  SELECTCASE make_hist_flag
    CASE 0 ' Move piezo to new point (ref:adw-mk-pz)
      makewait = 0
      avgcounter = 0
      make_acc = 0
      DEC(piezo_V)
      IF (piezo_V <= piezo_min) THEN
        state = 3 ' Go to end process
        IF (avgcurrent >= FPAR_11) THEN
          PAR_13 = PAR_13 + 2 ' Go to end process
        ENDIF

      ENDIF
      DAC(2,piezo_V)
      make_hist_flag = 1 ' Go to next stage

    CASE 1  ' Wait for stabilization (ref:adw-mk-wt)
      makewait = makewait + 1
      IF (makewait >= PAR_18) THEN
        make_hist_flag = 2 ' Go to next stage
      ENDIF

    CASE 2  ' Measure data (ref:adw-mk-msr)
      START_CONV(00011b)
      WAIT_EOC(00011b)
      make_acc = make_acc + DATA_10[READADC(1)+1]
      avgcounter = avgcounter + 1
      IF (avgcounter  >= PAR_19) THEN
        make_hist_flag = 3 ' Go to next stage
      ENDIF

    CASE 3  ' Store average in array  (ref:adw-mk-store)
      avgcurrent = make_acc / PAR_19
      DATA_3[PAR_21] = avgcurrent
      DATA_4[PAR_21] = piezo_V
      PAR_21 = PAR_21 + 1
      make_hist_flag = 0
#+END_SRC
**** DONE Adwin histogram-Event reset juncture voltage
     :PROPERTIES:
     :header-args+:  :tangle   no
     :END:
The algorithm to reset the juncture voltage is the same as the one used for the IV measurement. See  [[Adwin IV-Event reset juncture voltage]]
#+CAPTION: <<src-adwin-hist-reset-jv>> Code to restore the juncture value  to off value
#+NAME: src-adwin-hist-reset-jv
#+BEGIN_SRC basic :exports none
  <<src-adwin-iv-reset-jv>>
#+END_SRC

* Faulhaber Driver
  :PROPERTIES:
  :header-args+:  :tangle   modules/Faulhaber_driver.py
  :header-args+:  :noweb    tangle
  :header-args+:  :comments noweb
  :END:
The Faulhaber motor is used to perform the initial breaking of the juncture as it has a far larger dynamic range than possible with a single piezoelectric actuator. The driver class defines an interface for the rest of the program

As with many files, this file has a description header and the corresponding includes. In order to control the motor, the generic [[http://pyvisa.readthedocs.io/en/stable/index.html][Python Visa]] interface is used.
#+BEGIN_SRC python
  #################################################################
  ## @file    Faulhaber_driver.py
  #  @author  Joaquin Figueroa
  #  @date    Sun Sep 18, 2016
  #  @brief   Provides the interfaces for the Faulhaber motor
  #
  #  @details This file provides only the faulhaber interface,
  #           which defines high and low level functionalities.
  #           The user should use the high level functionality
  #           if possible.
  #           Also this file provides with some extra utilities
  #           that are not necesary inside the same faulhaber
  #           class.
  #################################################################
  import visa
#+END_SRC

The rest of the file is organized in 3 mayor sections:
- Constants :: The motor has some constant that are related to physical parameters of it, or the ports used for communication. These are defined in [[Faulhaber Constants]]
- Utilities :: There are some minor utilities that do not really belong inside the faulhaber class, these are defined in [[Faulhaber Utilities]]
- Faulhaber Driver :: The faulhaber driver is the python class that provides the full interface to the motor. Its defined in [[Faulhaber Driver Class]]

** Faulhaber Constants
As previously mentioned, the Faulhaber VISA interface, and some of the physical parameter of the motor are stored as global constants.
The constants are:
- Port :: Defined in line [[(fh-const-port)]], describes the port used to communicate with the motor.
- Baud rate :: Defined in line [[(fh-const-br)]]Is the communication rate in the channel used by the motor interface with the computer
- Motor Pitch :: Defined in line [[(fh-const-pitch)]], describes the pitch angle of the differential screw of the motor, relating a distance to an angle of the motor.
- Motor gearbox :: Defined in line [[(fh-const-gear)]], describes the gearbox multiplier of the motor, indicating how many full revolutions of the motor correspond to a given target angle.
- Motor Maximum position :: Described in line [[(fh-const-max)]] Describes the maximum position allowed for the motor as to avoid damaging the equipment.
- Motor Minimum position ::  Described in line [[(fh-const-min)]] Describes the minimum position allowed for the motor to avoid damaging the equipment
- Motor Max Speed :: Described in line [[(fh-const-max-speed)]] Describes the maximum speed in \([rpm]\) for the motor
- Motor Maximum acceleration  :: Described in line [[(fh-const-accel)]] Describes the maximum acceleration required for the motor  in \([\frac{rpm}{s}]\)

#+CAPTION: Description of the basic constants used by the faulhaber motor driver
#+NAME: src-faulhaber-constants
#+BEGIN_SRC python -n -r
  #################################################################
  ## @author  Joaquin Figueroa
  #  @brief   Constants used for the faulhaber interface
  #
  #  @details These are the constants used by the faulhaber
  #           interface.
  #################################################################
  class fh_const:
      port = "COM3" #(ref:fh-const-port)
      baud_rate = 9600 #(ref:fh-const-br)
      pitch = 150 #(ref:fh-const-pitch)
      gearbox = 246 #(ref:fh-const-gear)
      max_pos =  5000000#(ref:fh-const-max)
      min_pos = -7000000#(ref:fh-const-min)
      max_speed = 800#in RPM(ref:fh-const-max-speed)
      max_accel = 40#in RPM/s(ref:fh-const-accel)
#+END_SRC

** Faulhaber Utilities
The utilities are a set of functions that although related to the Faulhaber motor, are not really part of the interface to it. These function are used in the control interface to the motor.

*** Conversion functions
The interface to the Faulhaber motor is in \([rpm]\), however the magnitude has little meaning in the experiment, as the measured quantity is the displacement which is in \([\mu m]\), therefore conversion functions are used to move from one measurement to the other. Equation [[eq-conversion-rpm-ums]] shows the conversion formula using the motor *gearbox* and the *axis pitch*.

#+name: eq-conversion-rpm-ums
\begin{equation}
V_{rpm} = 60 \cdot gearbox \cdot \left(\dfrac{V_{\mu m/s}}{pitch}\right)
\end{equation}

#+BEGIN_SRC python
  #################################################################
  ## @brief   Converts motor speed from um/s to rpm
  #################################################################
  def faulhaber_convert_ums_to_rpm(ums):
      rpm = 60 * gearbox * (ums / pitch)
      return rpm

  #################################################################
  ## @brief   Converts motor speed from rpm to um/s
  #################################################################
  def faulhaber_convert_rpm_to_ums(rpm):
      ums = (rpm * pitch)/( 60 * gearbox)
      return ums
#+END_SRC

As an additional comment it can be pointed out that  \(1 [\mu m /s] \approx 100 [rpm]\), which means that at maximum acceleration (\(40 [rpm/s]\)) to reach the target speed it takes roughly \(2.5[s]\), which means that large displacements take very long times or that fine control is hard to achieve.

*** Faulhaber State
The Faulhaber motor, can only operate at seconds rates, however the control loop runs in less time. In order to properly control the motor, it's necessary to add state variables to help with the control loop and avoid overcontroling the motor.
#+BEGIN_SRC python
  class faulhaber_state():
      def __init__(self, start_pos, start_speed):
          self.start_pos = start_pos
          self.current_speed = start_speed
          self.previous_pos = [start_pos,start_pos,start_pos]
      def update_position(self, new_pos):
          self.previous_pos.append(new_pos)
          self.previous_pos.pop(0)
      # Depends on numpy abs to work on array
      def is_motor_stopped(self):
          a = self.previous_pos
          delta = sum(abs([a.(2) - a.(1),a.(1)-a.(0)]))
          return delta==0
      def update_current_speed(self, new_speed):
          self.current_speed = new_speed
#+END_SRC

** Faulhaber Driver Class
The Faulhaber class defined in the code block [[faulhaber-class-def]], provides the interface for all operation related to the motor. The functionality is distributed in 3 groups.
- Initialization function :: This function defined in line [[(fh-init-fn)]], ensures that the motor is prepared to excecute the instructions and defines the limits to it, in order to prevent damage to the motor. At the end of the initialization function the motor is disabled (turned off) to conserve power.
- Faulhaber Basic functions :: A set of functions defined in the  [[Faulhaber Basic Functions]], whose purpose is to provide the basic set of instructions to the motor. It's important to remember that these functions are not expected to be executed by the program dirctly, but to provide with the building blocks to create the interfaces to the program.
- Faulhaber Program Interface :: The set of functions defined in [[Faulhaber Program Interface]] provide with the instructions that make sense from the algorithm perspective and thus abstract the specific instructions of the motor from the high level program. These functions are the ones that should be called by a user program.
#+CAPTION: Faulhaber driver class definition
#+NAME: faulhaber-class-def
#+BEGIN_SRC python
  #################################################################
  ## @author  Joaquin Figueroa
  #  @brief   Faulhaber class interface
  #
  #  @details These are the constants used by the faulhaber
  #           interface.
  #################################################################
  class Faulhaber_motor:
      def __init__(self): #(ref:fh-init-fn)
      ###  Beware the interface may not be completely correct
          self.motor_ctrl = visa.SerialInstrument(fh_const.port)
          self.motor_ctrl.baud_rate = fh_const.baud_rate
      ###  Beware the interface may not be completely correct
          self._enable_motor()
          self._set_pos_range()
          self._set_respect_user_limits()
          self._set_max_speed()
          self._set_max_acceleration()
          self._disable_motor()
          self.state = self._init_state()
      <<faulhaber-basic-fn-interface>>
      <<faulhaber-real-interface>>
#+END_SRC
*** Faulhaber Basic Functions
    :PROPERTIES:
    :header-args+:  :tangle   no
    :END:
As previously stated this section defines the basic functions of the Faulhaber motor.
- Enable Motor :: This function enables the motor to allow it to move.
   #+NAME: faulhaber-basic-fn-interface
   #+BEGIN_SRC python
     #################################################################
     ## @brief   Enables the motor
     #################################################################
     def _enable_motor(self):
         self.motor_ctrl.write("en")
   #+END_SRC
- Disable motor :: This function disables the motor, stopping its movement
  #+NAME: faulhaber-basic-fn-interface
  #+BEGIN_SRC python
    #################################################################
    ## @brief   Disables the motor
    #################################################################
    def _disable_motor(self):
        self.motor_ctrl.write("di")
  #+END_SRC
- Respect user limits :: It seems that the motor may not respect the user defined limits by default, so this function forces the motor to do so
     #+NAME: faulhaber-basic-fn-interface
     #+BEGIN_SRC python
       #################################################################
       ## @brief   Ensures that the motor honor the user defined limits
       #################################################################
       def _set_respect_user_limits(self):
           self.motor_ctrl.write("APL 1")
     #+END_SRC
- Set motor position range :: This function set the maximum and minimum position of the motor axis to prevent damage to the equipment.
   #+NAME: faulhaber-basic-fn-interface
   #+BEGIN_SRC python
     #################################################################
     ## @brief   Set the maximum and minimum position for the motor axis
     #################################################################
     def _set_pos_range(self):
         max_pos_str = "LL %d" % fh_const.max_pos
         min_pos_str = "LL %d" % fh_const.min_pos
         self.motor_ctrl.write(max_pos_str)
         self.motor_ctrl.write(min_pos_str)
    #+END_SRC
- Set maximum speed :: This function defines the maximum speed for the motor.
   #+NAME: faulhaber-basic-fn-interface
     #+BEGIN_SRC python
     #################################################################
     ## @brief   Sets the maximum speed for the motor
     #################################################################
     def _set_max_speed(self):
         max_speed_str = "SP %d" %fh_const.max_speed
         self.motor_ctrl.write(max_speed_str)
     #+END_SRC
- Set maximum acceleration :: This function is used to set the maximum acceleration for the motor.
   #+NAME: faulhaber-basic-fn-interface
     #+BEGIN_SRC python
       #################################################################
       ## @brief   Sets the maximum acceleration for the motor
       #################################################################
       def _set_max_acceleration(self):
           max_accel_str = "SP %d" %fh_const.max_accel
           self.motor_ctrl.write(max_accel_str)
     #+END_SRC
- Set target speed :: This function is used to set a target speed for the continuous movement of the motor axis.
 #+NAME: faulhaber-basic-fn-interface
    #+BEGIN_SRC python
      #################################################################
      ## @brief   Sets the target speed of the motor
      #################################################################
      def _set_target_speed(self,speed):
          target_speed_str = "v %d" %speed
          self.state.update_speed(speed)
          self.motor_ctrl.write(target_speed_str)
     #+END_SRC
- Query axis position :: This function is used to determine the current axis position of the motor, which is used as a parameter to determine how much has the motor moved since the beginning of the execution. We define a motor the hardware query as =_query_current-axis_position=, and the real query to be used on the program as =_query_position=, which also updates the state
   #+NAME: faulhaber-basic-fn-interface
     #+BEGIN_SRC python
       #################################################################
       ## @brief   Returns the current axis position
       #  @Note    Not to be used directly in other parts of the program
       #################################################################
       def _query_current_axis_position(self):
           pos = self.motor_ctrl.query("pos")
           try:
               pos = int(pos)
               return pos
           except:
               self._set_target_speed(0)
               sleep(0.1)
               self._disable_motor()
               print("Error, Returned position was not a valid int")
               print(pos)
               raise

       #################################################################
       ## @brief   Returns the current axis position, updates the state
       #################################################################
       def _query_position(self):
           pos = self._query_current_axis_position()
           self.state.update_position(pos)
           return pos
     #+END_SRC
- Initialize State :: This function sets the starting state of the faulhaber motor, by analyzing the starting position and setting the intial speed to 0.
     #+NAME: faulhaber-basic-fn-interface
     #+BEGIN_SRC python
       #################################################################
       ## @brief   Initializes the motor state
       #################################################################
       def _init_state(self):
           start_pos = self._query_current_axis_position()
           self.state = faulhaber_state(start_pos,0)
     #+END_SRC

*** Faulhaber Program Interface
    :PROPERTIES:
    :header-args+:  :tangle   no
    :END:
The Faulhaber program interface is actually the control algorithm for the motor, this is, given a set of parameters, the control algorithm will set the new speed for the motor.

*** Faulhaber Control Algorithm
    :PROPERTIES:
    :header-args+:  :tangle   no
    :END:
In order to produce the most reliable measurements with the piezoelectric device, and with the least amount of noise for multiple measurements of the same samples, it's required to start the piezoelectric measurement *at the same data point* every time. Considering the characteristics of the experiment, there are only a few ways to ensure this.
1. Always start the measurement at the same *Displacement* of the motor, and hence the sample.
   To start the measurement at the same displacement is the ideal scenario, since the piezoelectric measurement could always produce an accurate *Conductance* over *Displacement* data, where the origin would allow for easy comparisons over different samples. Unfortunately it's not really possible to do this, since it would require very precise control of the motor, and handling of the sample. Also it would require uniform samples[fn:: In this context a sample is a gold device which may or may not have the molecule to study], and any variation of the sample thickness would require calibration, making this technique unfeasible
2. Always start the measurement at the same *Conductance* of the sample.
   This technique seems more feasible than the previous one as the experimental setup provides with a good mechanism to measure the conductance and the gold conductance is well studied so a target conductance can be set up in order to prepare the measurement. The disadvantage of this technique, is the need for an accurate control of the motor position and a more complex control loop in order to account for the possible oscillations and the slow response of the motor when compared to the computer speed.


#+ATTR_LATEX: :width 0.75\textwidth
#+CAPTION: High level view for the control algorithm of the Faulhaber motor
#+NAME: fig:ctrl-algorithm-flow
[[file:Doc/Dia/Motor_Control.png]]

Considering the alternatives, it was decided that a conductance based algorithm is the best alternative, and the control algorithm for the motor can be seen in figure [[fig:ctrl-algorithm-flow]] in which
- Break :: Corresponds to a parameter to the control algorithm to define if it should perform the breaking or release the sample
- Motor Make :: Is a simple control algorithm that releases the sample
- Motor Break :: Is a simple control algorithm that performs the breaking of the juncture
- Break restore :: Is a control algorithm that ensures that the juncture was broken and then closes the breaking
- Counter :: The counter is used to determine if there is need to perform the break-restore algorithm several times. Once the target number of runs is performed the control algorithm ends with the juncture restored up to a target *conductance*

As a final note, each algorithm updates the data of the run, as defined in [[Section to be defined]], and returns it as shown in the corresponding code fragment [[src-fh-ctrl-main-loop]]


#+CAPTION: Faulhaber main control loop in python as described by figure [[fig:ctrl-algorithm-flow]]
#+NAME: src-fh-ctrl-main-loop
#+BEGIN_SRC python
  #################################################################
  ## @author  Joaquin Figueroa
  #  @brief   Faulhaber Control Algorithm
  #
  #  @details The main control loop algorithm for the faulhaber
  #           motor. The algorithm is set in 3 main blocks:
  #           - Make: Releases the sample
  #           - Break : Breaks the juncture
  #           - Break-restore : Ensures the sample is broken
  #                             to restore the junction.
  #           interface.
  #################################################################
  def faulhaber_motor_control(self, break_junction, config):
      data_set = create_data_set()
      num_breakings = config.get_num_breakings()
      if(break_junction):
          counter = 0
          restore_data = data_set
          while(counter < num_breakings):
              break_data = self.motor_break(restore_data, config)
              restore_data = self.break_restore(break_data, config)
              counter = counter + 1
          return restore_data
      else:
          after_release_data = self.motor_make(data_set, config)
          return after_release_data
      raise
#+END_SRC

**** Faulhaber control-Motor Make
#+ATTR_LATEX: :width 0.75\textwidth
#+CAPTION: Control algorithm of the Faulhaber motor for the release sample algorithm
#+NAME: fig:ctrl-algorithm-motor-make
[[file:Doc/Dia/Motor_Make.png]]


The motor make algorithm as shown in figure [[fig:ctrl-algorithm-motor-make]] is excecuted to release set the motor back to a position in which the sample can be manipulated and removed from the equipment.

#+NAME: src-fh-ctrl-motor-make
#+CAPTION: Motor-make function
#+BEGIN_SRC python
  #################################################################
  ## @author  Joaquin Figueroa
  #  @brief   Moves the motor back to release the sample
  #
  #  @details Algorithm to release the sample from the equipment.
  #           Moves the motor which increases the conductance of the
  #           sample. If the conductance of the sample reaches a
  #           target value, then the sample was released and the
  #           motor is stopped.
  #################################################################
  def motor_make(self, data_set, config):
      G_target = config.get_target_make_conductance()
      updated_data_set = self.measure(data_set, config)
      G = updated_data_set.get_conductance()
      self.set_make_speed()
      while(G < G_target):
          sleep(config.get_ctrl_delay())
          updated_data_set = self.measure(updated_data_set, config)
          G = updated_data_set.get_conductance()
      make_data = self.stop_motor(updated_data_set, config)
      return make_data
#+END_SRC


**** Faulhaber control-Motor Break
#+ATTR_LATEX: :width 0.75\textwidth
#+CAPTION: Control algorithm of the Faulhaber motor for the break juncture algorithm
#+NAME: fig:ctrl-algorithm-motor-break
[[file:Doc/Dia/Motor_Break.png]]

The motor break algorithm shown in figure [[fig:ctrl-algorithm-motor-break]] moves the motor reducing the conductance until the target has been reached, then the motor is stopped.

#+NAME: src-fh-ctrl-motor-brak
#+CAPTION: Motor-break function
#+BEGIN_SRC python
  #################################################################
  ## @author  Joaquin Figueroa
  #  @brief   Moves the motor to break the gold channel
  #
  #  @details Algorithm to break the gold channel.
  #           Moves the motor which decreases the conductance of the
  #           sample. If the conductance of the sample reaches a
  #           target value, then the channel was broken and the
  #           motor is stopped.
  #################################################################
  def motor_break(self, data_set, config):
      G_target = config.get_target_break_conductance()
      updated_data_set = self.measure(data_set, config)
      G = updated_data_set.get_conductance()
      self.set_break_speed()
      while(G > G_target):
          sleep(config.get_ctrl_delay())
          updated_data_set = self.measure(data_set, config)
          G = updated_data_set.get_conductance()
      break_data = self.stop_motor(updated_data_set, config)
      return break_data
#+END_SRC


**** Faulhaber control-Motor Break-Restore
#+ATTR_LATEX: :width 0.75\textwidth
#+CAPTION: Control algorithm of the Faulhaber motor for the break-restore algorithm
#+NAME: fig:ctrl-algorithm-motor-break-restore
[[file:Doc/Dia/Motor_Break_restore.png]]

The motor break-restore algorithm tries to set the conductance to a target value within a tolerance setting. The idea behind the algorithm shown in figure [[fig:ctrl-algorithm-motor-break-restore]] is to:
1. If the motor was broken beyond the target value, restore the sample channel
2. If the sample channel was restored beyond the target, perform a single breaking step
3. Keep repeating until the target conductance is reached or a maximum number of oscillation were excecuted

#+NAME: src-fh-ctrl-motor-break-restore
#+CAPTION: Motor break-restore function
#+BEGIN_SRC python
  #################################################################
  ## @author  Joaquin Figueroa
  #  @brief   Moves the motor to drive the sample to a target G
  #
  #  @details Tries to ensure that the sample reaches a target
  #           conductance by performing several break and make
  #           steps, but for shorter times and smaller speeds.
  #           If the Motor starts to oscilate, the algorithm is
  #           stopped after a set number of steps
  #################################################################
  def break_restore(self, data_set, config):
      G_target = config.get_target_restore_conductance()
      tolerance = config.get_break_restore_tolreance()
      max_loop_counter = config.get_max_break_restore_loops()
      loop_counter = 0
      restore_loop = False
      while(loop_counter < max_loop_counter):
          data_set = self.measure(data_set, config)
          G = data_set.get_conductance()
          if(abs(G_target - G) < tolerance):
              data_set = self.stop_motor(data_set,config)
              G = data_set.get_conductance()
              if(abs(G_target - G) < tolerance):
                  break
              else:
                  continue
          else if(G < G_target):
              self.set_fine_make_speed()
              sleep(config.get_ctrl_delay())
              make_loop = True
          else:
              self.set_fine_break_speed()
              sleep(config.get_ctrl_delay())
              data_set = self.stop_motor(data_set,config)
              if(make_loop):
                  loop_counter = loop_counter +1
                  make_loop = False
#+END_SRC

* Utility functions
  :PROPERTIES:
  :header-args+: :comments noweb
  :END:

This section is for the interface with each measurement instrument.

* Settings                                                         :noexport:

** Python setup
 #+BEGIN_SRC emacs-lisp :export none :results none
   (setq org-babel-use-quick-and-dirty-noweb-expansion t)
   (org-babel-do-load-languages
    'org-babel-load-languages
    '((python . t)
      ))
   (setq org-babel-python-command "/bin/python2")
   (setq org-export-with-broken-links 'mark)
 #+END_SRC

** colorize
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-latex-packages-alist '("" "listings"))
  (setq org-latex-listings t)
#+END_SRC

#+RESULTS:
: t

** Basic-mode
#+BEGIN_SRC emacs-lisp :results none
  (defvar basic-events
    '("INIT"
      "END"
      "EVENT"))

  (defvar basic-keywords
    '("SELECTCASE"
      "CASE"
      "ENDSELECT"
      "IF"
      "THEN"
      "ELSE"
      "ENDIF"
      "DIM"
      "as"
      ))

  (defvar basic-comments "'.*")

  (defvar basic-functions
    '("INC"
      "DEC"
      "DAC"
      "set_MUX"
      "START_CONV"
      "WAIT_EOC"
      ))

  (defvar basic-types
    '("long"
      "float"
      ))

  (defvar basic-font-lock-defaults
    `((
       ;; stuff between "
       ( , basic-comments                 . font-lock-comment-face)
       ("\"\\.\\*\\?" . font-lock-string-face)
       ;; ; : , ; { } =>  @ $ = are all special elements
       (":\\|,\\|;\\|{\\|}\\|=>\\|@\\|$\\|=" . font-lock-constant-face)
       ( ,(regexp-opt basic-keywords 'words) . font-lock-keyword-face)
       ( ,(regexp-opt basic-events 'words) . font-lock-preprocessor-face)
       ( ,(regexp-opt basic-types 'words) . font-lock-type-face)
       ( ,(regexp-opt basic-functions 'words) . font-lock-function-name-face)
       ( ,"\\(F?PAR\\|DATA\\)_[0-9]+" . font-lock-builtin-face)
       )))

  (define-derived-mode basic-mode prog-mode "Basic"
    "Major mode for editing basic files."
    ;"Got it from https://www.emacswiki.org/emacs/DerivedMode"
    (setq-local comment-start "'")
    (setq-local comment-start-skip "'.*")
    (setq font-lock-defaults basic-font-lock-defaults)
    )
  (provide 'basic-mode)

  (add-to-list 'auto-mode-alist '("\\.bas\\'" . basic-mode))
#+END_SRC
